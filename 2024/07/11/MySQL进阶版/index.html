

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/computer.png">
  <link rel="icon" href="/img/computer.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>MySQL进阶 - Dachao&#39;s bolg</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Dchao's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="MySQL进阶">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-07-11 22:21" pubdate>
        2024年7月11日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      325
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL进阶</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：6 分钟前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h2><h3 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h3><blockquote>
<p><img src="../img/5f42ae4dbfd64c33a56a9e36d6b150b3.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="1-2-存储引擎简介"><a href="#1-2-存储引擎简介" class="headerlink" title="1.2 存储引擎简介"></a>1.2 存储引擎简介</h3><blockquote>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，<strong>所以存储引擎也可被称为表类型。</strong></p>
</blockquote>
<p> 查询表的创建信息：<strong>show create table</strong> 表名；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table accont;<br></code></pre></td></tr></table></figure>

<p><img src="../img/9e9729493bd04501bc5c3eb92e348cc7.png" srcset="/img/loading.gif" lazyload> </p>
<p>在创建表时，指定存储引擎</p>
<p><img src="../img/31407a58d8964e248b45fad8a4c54dee-0706769.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建表，指定引擎为MyISAM<br>create table my_myisam(<br>    id int,<br>    name varchar(10)<br>) engine = MyISAM;<br></code></pre></td></tr></table></figure>

<p>查看当前数据库支持的存储引擎</p>
<p><img src="../img/aea1900c66c3407098d6ca0fba7202d4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-3-存储引擎特点"><a href="#1-3-存储引擎特点" class="headerlink" title="1.3 存储引擎特点"></a>1.3 存储引擎特点</h3><p><img src="../img/2ea53424a3a34a97832f084aee8e4125.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>主要使用InnoDB 和 MyISAM</p>
</blockquote>
<p> 查看系统变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;innodb_file_per_table&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="../img/50464cee661647ce93926fa98f711f68.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-3-1-InnoDB"><a href="#1-3-1-InnoDB" class="headerlink" title="1.3.1 InnoDB"></a>1.3.1 InnoDB</h4><blockquote>
<p>                InnoDB是一种兼顾高可靠性和高性能行的通用存储引擎，在MySQL 5.5 之后，InnoDB时默认的存储引擎</p>
<p>        <strong>特点：</strong></p>
<p>                DML操作遵循ACID模型，支持事务</p>
<p>                行级锁，  提高并发访问性能；</p>
<p>                支持外键foreign key 约束，保证数据的完整性和正确性；</p>
<p>        <strong>文件：</strong></p>
<p>                xxx.ibd: xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</p>
<p>                参数：<strong>innodb_file_per_table</strong></p>
<p>        <strong>逻辑存储结构：</strong></p>
<p>                Tablespace：表空间</p>
<p>                Segment:段</p>
<p>                Extent：区</p>
<p>                Page： 页</p>
<p>                Pow：行 </p>
<p>                <img src="../img/d8b0f8ec8068415fb1d31c2e41d5825b.png" srcset="/img/loading.gif" lazyload></p>
<p>        </p>
</blockquote>
<h4 id="1-3-2-MyISAM"><a href="#1-3-2-MyISAM" class="headerlink" title="1.3.2 MyISAM"></a>1.3.2 MyISAM</h4><blockquote>
<p>                  MyISAM是MySQL早期默认存储引擎</p>
<p>         <strong>特点：</strong></p>
<p>                 不支持事务，不支持外键</p>
<p>                 支持表锁，不支持行锁</p>
<p>                 访问速度快</p>
<p>         <strong>文件：</strong></p>
<p>                 xxx.sdi：存储表结构信息</p>
<p>                 xxx.MYD：存储数据</p>
<p>                 xxx.MYI：存储索引</p>
</blockquote>
<h4 id="1-3-3-Memory"><a href="#1-3-3-Memory" class="headerlink" title="1.3.3 Memory"></a>1.3.3 Memory</h4><blockquote>
<p>                  Memory引擎的表数据是存储在内存中的，由于受到硬件问题或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>         <strong>特点：</strong></p>
<p>                 内存存放</p>
<p>                 hash索引（默认）</p>
<p>         <strong>文件：</strong></p>
<p>                 xxx.sdi：存储表结构信息</p>
</blockquote>
<h3 id="1-4-存储引擎选择"><a href="#1-4-存储引擎选择" class="headerlink" title="1.4 存储引擎选择"></a>1.4 存储引擎选择</h3><blockquote>
<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>  InnoDB：是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择</li>
<li>  MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>  MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表以及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法存在内存中，而且无法保证数据的安全性。</li>
</ul>
</blockquote>
<h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><blockquote>
<p>索引（ index ）是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构</strong> ( <strong>有序</strong> ) 。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<p><strong>演示：</strong></p>
<p>表结构及其数据如下：</p>
<p><img src="../img/f6a0f615afe24d0496b559c9cf7aaa29.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>假如我们要执行的 SQL 语句为 ： select * from user where age = 45;</p>
<p>1). <strong>无索引</strong>情况</p>
<p><img src="../img/811f35722ce047b8b11b7296cb12463d.png" srcset="/img/loading.gif" lazyload></p>
<p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。</p>
<p>2). <strong>有索引</strong>情况</p>
<p>如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对 age 这个字段建立一个二叉树的索引结构</p>
<p><img src="../img/2e0e25ac74aa4d00b7a865bba06cb344.png" srcset="/img/loading.gif" lazyload></p>
<p>此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率</p>
<p><strong>备注： 这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并</strong></p>
<p><strong>不是索引的真实结构，索引的真实结构，后面会详细介绍。</strong></p>
<p>特点：</p>
<p><img src="../img/85c1e21c331640df993286bd71051866.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-2-索引结构"><a href="#2-2-索引结构" class="headerlink" title="2.2 索引结构"></a>2.2 索引结构</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 <strong>概述</strong></h4><blockquote>
<p>MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>
<p><img src="../img/6efe501541f04bb8a984b9bf349ba0b2.png" srcset="/img/loading.gif" lazyload></p>
<p>上述是 MySQL 中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。</p>
<p><img src="../img/a19711adef0e4e06b93eabdc9e9733e0.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</strong></p>
</blockquote>
<h4 id="2-2-2-二叉树"><a href="#2-2-2-二叉树" class="headerlink" title="2.2.2 二叉树"></a>2.2.2 二叉树</h4><blockquote>
<p>  假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p>
<p> <img src="../img/dd06dea3933b41f6971582bf63ea44b8.png" srcset="/img/loading.gif" lazyload></p>
<p> 如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p>
<p> <img src="../img/8ec96200c7b34b60813a7af0c9ba1518.png" srcset="/img/loading.gif" lazyload></p>
<p> 所以，如果选择二叉树作为索引结构，会存在以下<strong>缺点</strong>：</p>
<p> *   <strong>顺序插入时，会形成一个链表，查询性能大大降低。</strong><br> *   <strong>大数据量情况下，层级较深，检索速度慢。</strong></p>
<p> 此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树, 结构如下 :</p>
<p> <img src="../img/4f5a8ff8266f49c1a85332676e8ce9dc.png" srcset="/img/loading.gif" lazyload></p>
<p> 但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个<strong>缺点</strong>：</p>
<p> *   <strong>大数据量情况下，层级较深，检索速度慢。</strong></p>
</blockquote>
<p>所以，在 MySQL 的索引结构中，并没有选择二叉树或者红黑树，而选择的是 B+Tree ，那么什么是</p>
<p>B+Tree 呢？在详解 B+Tree 之前，先来介绍一个 <strong>B-Tree</strong> 。</p>
<h4 id="2-2-3-B-Tree"><a href="#2-2-3-B-Tree" class="headerlink" title="2.2.3 B-Tree"></a>2.2.3 B-Tree</h4><blockquote>
<p>B-Tree ， B 树是一种多叉路衡查找树，相对于二叉树， B 树每个节点可以有多个分支，即叉。以一颗最大度数（max-degree ）为 5(5 阶 ) 的 b-tree 为例，那这个 B 树每个节点最多存储 key ， 5</p>
<p>个指针：</p>
<p><img src="../img/58290eca1fd04febb1216bb55761a897.png" srcset="/img/loading.gif" lazyload></p>
<p>知识小贴士 : 树的度数指的是一个节点的子节点个数。</p>
<p>我们可以通过一个数据结构可视化的网站来简单演示一下。 <strong><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></strong></p>
</blockquote>
<p><img src="../img/e6af415dd2564e9d8e04e3dca8cf2fa8.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>插入一组数据：</strong> 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88</p>
<p>120 268 250 。<strong>然后观察一些数据插入过程中，节点的变化情况。</strong></p>
<p><img src="../img/4b76d70ae5a4448bbe1e1ae7c0ed4013.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>  <strong>特点：</strong></p>
<p> *   <strong>5阶的B树，每一个节点最多存储4个key，对应5个指针。</strong><br> *   <strong>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</strong><br> *   <strong>在B树中，非叶子节点和叶子节点都会存放数据。</strong></p>
</blockquote>
<h4 id="2-2-4-B-Tree"><a href="#2-2-4-B-Tree" class="headerlink" title="2.2.4 B+Tree"></a><strong>2.2.4 B+Tree</strong></h4><blockquote>
<p>B+Tree 是 B-Tree 的变种，我们以一颗最大度数（ max-degree ）为 4（ 4阶）的 b+tree 为例，来看一下其结构示意图：</p>
<p><img src="../img/9c9c21380e78434992584707751df39a.png" srcset="/img/loading.gif" lazyload></p>
<p>我们可以看到，两部分：</p>
<ul>
<li>  绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li>
<li>  红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li>
</ul>
<p>我们可以通过一个数据结构可视化的网站来简单演示一下。 <strong><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></strong></p>
</blockquote>
<blockquote>
<p><img src="../img/48dd926f0bae463ea2e79e6ebd4dc94e.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>插入一组数据：</strong> 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88</p>
<p>120 268 250 。<strong>然后观察一些数据插入过程中，节点的变化情况</strong>。</p>
<p><img src="../img/6a3881523c92472ca3bfa3853ee75220.png" srcset="/img/loading.gif" lazyload></p>
<p>最终我们看到， B+Tree 与 B-Tree 相比，主要有以下三点区别：</p>
<ul>
<li>  <strong>所有的数据都会出现在叶子节点。</strong></li>
<li>  <strong>叶子节点形成一个单向链表。</strong></li>
<li>  <strong>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</strong></li>
</ul>
</blockquote>
<blockquote>
<p>                上述我们所看到的结构是标准的B+Tree 的数据结构，接下来，我们再来看看 MySQL 中优化之后的B+Tree。</p>
<p>                MySQL索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree ，提高区间访问的性能，利于排序。</p>
<p>         <img src="../img/e3fa54a0b3f64f8ba3c85d22ad77143e.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="2-2-5-Hash"><a href="#2-2-5-Hash" class="headerlink" title="2.2.5 Hash"></a><strong>2.2.5 Hash</strong></h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型-–Hash索引。</p>
<blockquote>
<p><strong>1). 结构</strong></p>
<p>哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在hash表中。</p>
<p><img src="../img/ed8e6a24f8dd460cbf903d394eca4a11.png" srcset="/img/loading.gif" lazyload></p>
<p>如果两个 ( 或多个 ) 键值，映射到一个相同的槽位上，他们就产生了 hash 冲突（也称为 hash 碰撞），可以通过链表来解决。</p>
<p><img src="../img/0007a0cde24d42fd888d4643c1c49c68.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<blockquote>
<p><strong>2). 特点</strong>  </p>
<ul>
<li>  <strong>Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</strong></li>
<li>  <strong>无法利用索引完成排序操作</strong></li>
<li>  <strong>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</strong></li>
</ul>
</blockquote>
<blockquote>
<p><strong>3). 存储引擎支持</strong> </p>
<p>在 MySQL 中，支持 hash 索引的是 Memory 存储引擎。 而 InnoDB 中具有自适应 hash 功能， hash 索引是InnoDB存储引擎根据 B+Tree 索引在指定条件下<strong>自动构建</strong>的。</p>
</blockquote>
<p>思考题： 为什么InnoDB存储引擎选择使用B+tree索引结构?</p>
<p>A. 相对于二叉树，层级更少，搜索效率高；</p>
<p>B. <strong>对于B-tree</strong> ，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储</p>
<p>    的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p>
<p>C. 相对 Hash 索引， <strong>B+tree</strong> <strong>支持范围匹配及排序操作</strong>；</p>
<h3 id="2-3-索引分类"><a href="#2-3-索引分类" class="headerlink" title="2.3 索引分类"></a>2.3 索引分类</h3><h4 id="2-3-1-索引分类"><a href="#2-3-1-索引分类" class="headerlink" title="2.3.1 索引分类"></a><strong>2.3.1</strong> <strong>索引分类</strong></h4><blockquote>
<p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>
<p><img src="../img/ea5cc8c0e8cf4b549afc45c254a58821.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="2-3-2-聚集索引-amp-二级索引"><a href="#2-3-2-聚集索引-amp-二级索引" class="headerlink" title="2.3.2 聚集索引&amp;二级索引"></a><strong>2.3.2</strong> <strong>聚集索引</strong>&amp;<strong>二级索引</strong></h4><blockquote>
<p>  而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<p> <img src="../img/1eb0bc3e944141d6a2b7c003adc19b72.png" srcset="/img/loading.gif" lazyload></p>
<p> 聚集索引选取规则 :</p>
<p> *   <strong>如果存在主键，主键索引就是聚集索引。如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</strong><br> *   <strong>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</strong></p>
<p> 聚集索引和二级索引的具体结构如下：</p>
<p> <img src="../img/cbd29a843ba141db9ccec0f468225e79.png" srcset="/img/loading.gif" lazyload></p>
<p> *   <strong>聚集索引的叶子节点下挂的是这一行的数据 。</strong><br> *   <strong>二级索引的叶子节点下挂的是该字段值对应的主键值。</strong></p>
</blockquote>
<p>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p>
<p><img src="../img/c044dd12e68944dbb2c27b96d8ba53ef.png" srcset="/img/loading.gif" lazyload></p>
<p>具体过程如下 :</p>
<p>① . 由于是根据 name 字段进行查询，所以先根据 name=’Arm’ 到 name 字段的二级索引中进行匹配查</p>
<p>      找。但是在二级索引中只能查找到 Arm 对应的主键值 10 。</p>
<p>② . 由于查询返回的数据是 * ，所以此时，还需要根据主键值 10 ，到聚集索引中查找 10 对应的录，         最终找到10 对应的行 row 。</p>
<p>③ . 最终拿到这一行的数据，直接返回即可。</p>
<blockquote>
<p><strong>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</strong></p>
</blockquote>
<blockquote>
<p>假设 :</p>
<p>一行数据大小为 1k ，一页中可以存储 16 行这样的数据。 InnoDB 的指针占用 6 个字节的空</p>
<p>间，主键即使为 bigint ，占用字节数为 8 。</p>
<p>高度为 2 ：</p>
<p>n * 8 + (n + 1) * 6 = 16*1024 , 算出 n 约为 1170</p>
<p>1171* 16 = 18736</p>
<p>也就是说，如果树的高度为 2 ，则可以存储 18000 多条记录。</p>
<p>高度为 3 ：</p>
<p>1171 * 1171 * 16 = 21939856</p>
<p>也就是说，如果树的高度为 3 ，则可以存储 2200w 左右的记录。</p>
</blockquote>
<h3 id="2-4-索引语法"><a href="#2-4-索引语法" class="headerlink" title="2.4 索引语法"></a>2.4 索引语法</h3><blockquote>
<p><strong>1). 创建索引</strong></p>
<p>        <strong>create [unique | fulltext ] index</strong> 索引名 <strong>on</strong> 表名(字段名)</p>
<p><strong>2). 查看索引</strong></p>
<p>        <strong>show index from</strong> 表名;</p>
<p><strong>3). 删除索引</strong></p>
<p>        <strong>drop index</strong> 索引名 <strong>on</strong> 表名;</p>
</blockquote>
<h3 id="2-5-SQL性能分析"><a href="#2-5-SQL性能分析" class="headerlink" title="2.5 SQL性能分析"></a>2.5 SQL性能分析</h3><h4 id="2-5-1-SQL执行频率"><a href="#2-5-1-SQL执行频率" class="headerlink" title="2.5.1 SQL执行频率"></a><strong>2.5.1 SQL</strong>执行频率</h4><blockquote>
<p>MySQL 客户端连接成功后，通过 <strong>show [session|global] status</strong> 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT 、 UPDATE 、 DELETE 、 SELECT 的访问频次：</p>
<p>-- session 是查看当前会话 ;</p>
<p>-- global 是查询全局数据 ;</p>
<p><strong>show global status like ‘Com_______‘(七个下划线）</strong></p>
<p><img src="../img/fcb0dce43c74433e94623b10522399a0.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>  Com_delete: 删除次数</p>
</li>
<li><p>  Com_insert: 插入次数</p>
</li>
<li><p>  Com_select: 查询次数</p>
</li>
<li><p>  Com_update: 更新次数</p>
</li>
</ul>
<p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p>
</blockquote>
<h4 id="2-5-2-慢查询日志"><a href="#2-5-2-慢查询日志" class="headerlink" title="2.5.2 慢查询日志"></a><strong>2.5.2</strong> <strong>慢查询日志</strong></h4><blockquote>
<p>慢查询日志记录了所有执行时间超过指定参数（ long_query_time ，单位：秒，默认 10 秒）的所有SQL语句的日志。</p>
<p>MySQL 的慢查询日志默认没有开启，我们可以查看一下系统变量 <strong>slow_query_log</strong> 。</p>
<p><img src="../img/d70c0380a5fb4e1cbef803169c71a58d.png" srcset="/img/loading.gif" lazyload></p>
<p>如果要开启慢查询日志，需要在 MySQL 的配置文件（ /etc/my.cnf ）中配置如下信息：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启MySQL慢日志查询开关</span><br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-number">1</span><br><span class="hljs-comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>配置完毕之后，通过以下指令重新启动 MySQL 服务器进行测试，查看慢日志文件中记录的信息</p>
<p><strong>/var/lib/mysql/localhost-slow.log</strong> 。</p>
<p>然后，再次查看开关情况，慢查询日志就已经打开了。</p>
<p><img src="../img/7c6e6b4f87b44150bcef81ec2cc8aa65.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p> <strong>测试：</strong></p>
<p>A. 执行如下 SQL 语句 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user; <span class="hljs-comment">-- 这条SQL执行效率比较高, 执行耗时 0.00sec</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_sku; <span class="hljs-comment">-- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec</span><br></code></pre></td></tr></table></figure>

<p><img src="../img/7f251bbbe50a4847af78e10b19d3daf2.png" srcset="/img/loading.gif" lazyload></p>
<p>B. 检查慢查询日志 ：</p>
<p>在**/var/lib/mysql**中</p>
<p>最终我们发现，在慢查询日志中，只会记录执行时间超多我们预设时间（ 2s ）的 SQL ，执行较快的 SQL是不会记录的。</p>
<p><img src="../img/b207beef3dc94095ad57eacb7adf8554.png" srcset="/img/loading.gif" lazyload></p>
<p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。 </p>
<h4 id="2-5-3-profile详情"><a href="#2-5-3-profile详情" class="headerlink" title="2.5.3 profile详情"></a><strong>2.5.3 profile</strong>详情</h4><blockquote>
<p>show profiles 能够在做 SQL 优化时帮助我们了解时间都耗费到哪里去了。通过 have_profiling</p>
<p>参数，能够看到当前 MySQL 是否支持 profile 操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@have</span>_profiling ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/fd836af72a9b47e787828176d75bdb09.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，当前 MySQL 是支持 profile 操作的，但是开关是关闭的。可以通过 set语句在session/global 级别开启 profiling ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET profiling = 1;<br></code></pre></td></tr></table></figure>

<p>开关已经打开了，接下来，我们所执行的 SQL 语句，都会被 MySQL 记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;白起&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>执行一系列的业务 SQL 的操作，然后通过如下指令查看指令的执行耗时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看每一条SQL的耗时基本情况</span><br><span class="hljs-keyword">show</span> profiles;<br><span class="hljs-comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id;<br><span class="hljs-comment">-- 查看指定query_id的SQL语句CPU的使用情况</span><br><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>查看每一条SQL的耗时情况:</p>
<p> <img src="../img/eefb9277fcdc4298b918ff29daa41880.png" srcset="/img/loading.gif" lazyload></p>
<p>查看指定 SQL 各个阶段的耗时情况 :</p>
<p><img src="../img/18afd3f88aff4747ab0d4dab776bcf73.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-5-4-执行计划-explain"><a href="#2-5-4-执行计划-explain" class="headerlink" title="2.5.4 执行计划 explain"></a><strong>2.5.4 执行计划 explain</strong></h4><blockquote>
<p><strong>EXPLAIN</strong> 或者 <strong>DESC</strong> 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<p>-- 直接在 select 语句之前加上关键字 explain / desc</p>
<ul>
<li>  <strong>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</strong></li>
</ul>
<p><img src="../img/064ab2c4501e42c399d83bf9a8952108.png" srcset="/img/loading.gif" lazyload></p>
<p>Explain 执行计划中部分字段的含义 :</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">select 查询的序列号，表示查询中执行 select 子句或者是操作表的顺序 (id相同，执行顺序从上到下； id 不同，值越大，越先执行 ) 。</td>
</tr>
<tr>
<td align="left">select_type</td>
<td align="left">表示 SELECT 的类型，常见的取值有 SIMPLE （简单表，即不使用表连接或者子查询）、 PRIMARY （主查询，即外层的查询）、UNION （ UNION 中的第二个或者后面的查询语句）、SUBQUERY （ SELECT/WHERE 之后包含了子查询）等</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">表示连接类型，性能由好到差的连接类型为 NULL 、 system 、 const 、eq_ref、 ref 、 range 、 index 、 all 。</td>
</tr>
<tr>
<td align="left">possible_key</td>
<td align="left">显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">实际使用的索引，如果为 NULL ，则没有使用索引。</td>
</tr>
<tr>
<td align="left">key_len</td>
<td align="left">表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td align="left">rows</td>
<td align="left">MySQL 认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值，可能并不总是准确的。</td>
</tr>
<tr>
<td align="left">filtered</td>
<td align="left">表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
</tbody></table>
<p><strong>详细含义</strong></p>
<p>查询结构中有12列，理解每一列的含义，对理解执行计划至关重要，下面进行说明。</p>
<p><strong>id</strong></p>
<p>SELECT识别符，这是SELECT的查询序列号。</p>
<p><strong>select_type</strong></p>
<p>SELECT类型,可以为以下任何一种:</p>
<ul>
<li>SIMPLE:简单SELECT(不使用UNION或子查询)</li>
<li>PRIMARY:最外面的SELECT</li>
<li>UNION:UNION中的第二个或后面的SELECT语句</li>
<li>DEPENDENT UNION:UNION中的第二个或后面的SELECT语句,取决于外面的查询</li>
<li>UNION RESULT:UNION 的结果</li>
<li>SUBQUERY:子查询中的第一个SELECT</li>
<li>DEPENDENT SUBQUERY:子查询中的第一个SELECT,取决于外面的查询</li>
<li>DERIVED:导出表的SELECT(FROM子句的子查询)</li>
</ul>
<p><strong>table</strong></p>
<p>输出的行所引用的表</p>
<p><strong>partitions</strong></p>
<p>如果查询是基于分区表的话，显示查询将访问的分区。</p>
<p><strong>type</strong></p>
<p>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:</p>
<ul>
<li>system:表仅有一行(=系统表)。这是const联接类型的一个特例。</li>
<li>const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!</li>
<li>eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。</li>
<li>ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。</li>
<li>ref_or_:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。</li>
<li>index_merge:该联接类型表示使用了索引合并优化方法。</li>
<li>unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</li>
<li>index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</li>
<li>range:只检索给定范围的行,使用一个索引来选择行。</li>
<li>index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。</li>
<li>ALL:对于每个来自于先前的表的行组合,进行完整的表扫描，说明查询就需要优化了。</li>
</ul>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p><strong>possible_keys</strong></p>
<p>指出MySQL能使用哪个索引在该表中找到行</p>
<p><strong>key</strong></p>
<p>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</p>
<p><strong>key_len</strong></p>
<p>显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。在不损失精确性的情况下，长度越短越好</p>
<p><strong>ref</strong></p>
<p>显示使用哪个列或常数与key一起从表中选择行。</p>
<p><strong>rows</strong></p>
<p>显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。</p>
<p><strong>filtered</strong></p>
<p>显示了通过条件过滤出的行数的百分比估计值。</p>
<p><strong>Extra</strong></p>
<p>该列包含MySQL解决查询的详细信息</p>
<ul>
<li>Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。</li>
<li>Select tables optimized away MySQL根本没有遍历表或索引就返回数据了，表示已经优化到不能再优化了</li>
<li>Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。</li>
<li>range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。</li>
<li>Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行，说明查询就需要优化了。</li>
<li>Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。</li>
<li>Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果，说明查询就需要优化了。</li>
<li>Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。</li>
<li>Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。</li>
<li>Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。</li>
</ul>
<h3 id="2-6-索引使用"><a href="#2-6-索引使用" class="headerlink" title="2.6 索引使用"></a>2.6 索引使用</h3><h4 id="2-6-1-验证索引效率"><a href="#2-6-1-验证索引效率" class="headerlink" title="2.6.1 验证索引效率"></a><strong>2.6.1</strong> <strong>验证索引效率</strong></h4><blockquote>
<p>在讲解索引的使用原则之前，先通过一个简单的案例，来验证一下索引，看看是否能够通过索引来提升数据查询性能。</p>
<p><strong>1.</strong> 在演示的时候，我们还是使用之前准备的一张表 tb_sku , 在这张表中准备了 1000w的记录。</p>
<ul>
<li>  <strong>select * from tb_sku where id = 1\G;</strong></li>
</ul>
<p><img src="../img/6bf10564758841a49cbfe3f89f1ad543.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到即使有 1000w 的数据 , 根据 id 进行数据查询 , 性能依然很快，因为主键 id 是有索引的。 <strong>2.</strong> 那么接下来，我们再来根据 sn 字段进行查询，执行如下 SQL ：</p>
<ul>
<li>   <strong>select* from tb_sku where sn = ‘100000003145001’;</strong></li>
</ul>
<p><img src="../img/c15a873e6b594a8896d3795e139768fc.png" srcset="/img/loading.gif" lazyload></p>
<p>我们可以看到根据 sn 字段进行查询，查询返回了一条数据，结果耗时 14.08 sec ，就是因为 sn 没有索引，而造成查询效率很低。</p>
<p><strong>3.</strong> 那么我们可以针对于 sn 字段，建立一个索引，建立了索引之后，我们再次根据 sn 进行查询，再来看一下查询耗时情况。</p>
<p>创建索引：</p>
<ul>
<li>  <strong>create index idx_sku_sn on tb_sku(sn) ;</strong></li>
</ul>
<p><img src="../img/420c188f8be94c85a1219aa4edda4c28.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>4.</strong> 然后再次执行相同的 SQL 语句，再次查看 SQL 的耗时。</p>
<ul>
<li>  <strong>select * from tb_sku where sn = ‘100000003145001’;</strong></li>
</ul>
<p><img src="../img/707e95fe139b4ef6902518dd01e4015c.png" srcset="/img/loading.gif" lazyload></p>
<p>我们明显会看到， sn 字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数量级的。</p>
</blockquote>
<h4 id="2-6-2-最左前缀法则"><a href="#2-6-2-最左前缀法则" class="headerlink" title="2.6.2 最左前缀法则"></a><strong>2.6.2</strong> <strong>最左前缀法则</strong></h4><blockquote>
<p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效( 后面的字段索引失效 ) 。</p>
<p>以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。</p>
<p><img src="../img/76f0217a2d10458eb3e59ba5b3c20f5a.png" srcset="/img/loading.gif" lazyload></p>
<p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为： profession ，age， status 。</p>
<p>对于最左前缀法则指的是，查询时，最左变的列，也就是 profession 必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下具体的执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1 索引123都在<br>explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;<br><br>-- 2 仅有索引12<br>explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31;<br><br>-- 3 仅有索引1<br>explain select * from tb_user where profession = &#x27;软件工程&#x27;;<br><br>-- 4 仅有索引23<br>explain select * from tb_user where age = 31 and status = &#x27;0&#x27;;<br><br>-- 5 仅有索引3<br>explain select * from tb_user where status = &#x27;0&#x27;;<br><br>-- 6 仅有13<br>explain select * from tb_user where profession = &#x27;软件工程&#x27; and status = &#x27;0&#x27;;<br></code></pre></td></tr></table></figure>

<p>1.</p>
<p><img src="../img/84d8d7da40274aa1ac011970fa52c304.png" srcset="/img/loading.gif" lazyload></p>
<p>2.</p>
<p><img src="../img/ea140fb3a56540af888ed625e7726a86.png" srcset="/img/loading.gif" lazyload></p>
<p>3.</p>
<p><img src="../img/cfdf54c9c5914609b347423abbeaadd4.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  以上的这三组测试中，我们发现<strong>只要联合索引最左边的字段</strong> <strong>profession</strong>存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age字段索引长度为2、status字段索引长度为5。</li>
</ul>
<p>4.<img src="../img/dc29003b70fb4afdb83566d95fe97d43.png" srcset="/img/loading.gif" lazyload></p>
<p>5.</p>
<p><img src="../img/d3720af6c42b456089fc0d9441157fe7.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在。</li>
</ul>
<p>6.<img src="../img/139af7bb766b458b945284d90325d4d8.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  上述的SQL查询时，存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。</li>
</ul>
</blockquote>
<h4 id="2-6-3-范围查询"><a href="#2-6-3-范围查询" class="headerlink" title="2.6.3 范围查询"></a><strong>2.6.3</strong> <strong>范围查询</strong></h4><blockquote>
<p>联合索引中，出现范围查询 (&gt;,&lt;) ，范围查询右侧的列索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where profession = &#x27;软件工程&#x27; and age &gt; 30 and status = &#x27;0&#x27;;<br><br>explain select * from tb_user where profession = &#x27;软件工程&#x27; and age &gt;= 30 and status = &#x27;0&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="../img/ce63fd6302564447b703993fa5835546.png" srcset="/img/loading.gif" lazyload></p>
<p>当范围查询使用 &gt; 或 &lt; 时，走联合索引了，但是索引的长度为 49 ，就说明范围查询右边的 status 字段是没有走索引的。</p>
<p><img src="../img/ae9986d9bde24cf682d92623ae28710a.png" srcset="/img/loading.gif" lazyload></p>
<p>当范围查询使用 &gt;= 或 &lt;= 时，走联合索引了，但是索引的长度为 54 ，就说明所有的字段都是走索引的。</p>
<p><strong>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</strong></p>
</blockquote>
<h4 id="2-6-4-索引失效情况"><a href="#2-6-4-索引失效情况" class="headerlink" title="2.6.4 索引失效情况"></a><strong>2.6.4</strong> <strong>索引失效情况</strong></h4><h5 id="2-6-4-1-索引列运算"><a href="#2-6-4-1-索引列运算" class="headerlink" title="2.6.4.1 索引列运算"></a><strong>2.6.4.1</strong> <strong>索引列运算</strong></h5><blockquote>
<p>不要在索引列上进行运算操作， 索引将失效。</p>
<ul>
<li>  当根据phone字段进行等值匹配查询时, <strong>索引生效</strong>。</li>
</ul>
<p>        explain select * from tb_user where phone = ‘17799990015’ ;</p>
<ul>
<li>  当根据 phone 字段进行函数运算操作之后，<strong>索引失效</strong>。</li>
</ul>
<p>        explain select * from tb_user where substring(phone, 10 , 2 ) = ‘15’ ;</p>
</blockquote>
<h5 id="2-6-4-2-字符串不加引号"><a href="#2-6-4-2-字符串不加引号" class="headerlink" title="2.6.4.2 字符串不加引号"></a><strong>2.6.4.2</strong> <strong>字符串不加引号</strong></h5><blockquote>
<p><strong>字符串类型</strong>字段使用时，<strong>不加引号</strong>，索引将失效。</p>
<p>存在类型转换</p>
</blockquote>
<h5 id="2-6-4-3-模糊查询"><a href="#2-6-4-3-模糊查询" class="headerlink" title="2.6.4.3 模糊查询"></a><strong>2.6.4.3</strong> <strong>模糊查询</strong></h5><blockquote>
<p>如果仅仅是<strong>尾部模糊匹配，索引不会失效</strong>。如果是头部模糊匹配，索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 索引生效<br>explain select * from tb_user where profession like &#x27;软件%&#x27;;<br>-- 索引失效<br>explain select * from tb_user where profession like &#x27;%工程&#x27;;<br>explain select * from tb_user where profession like &#x27;%工%&#x27;;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-6-4-4-or连接条件"><a href="#3-6-4-4-or连接条件" class="headerlink" title="3.6.4.4 or连接条件"></a><strong>3.6.4.4 or</strong>连接条件</h5><blockquote>
<p>用 or 分割开的条件， 如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
</blockquote>
<h5 id="3-6-4-5-数据分布影响"><a href="#3-6-4-5-数据分布影响" class="headerlink" title="3.6.4.5 数据分布影响"></a><strong>3.6.4.5</strong> <strong>数据分布影响</strong></h5><blockquote>
<p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p>
<p>        经过测试我们发现，相同的SQL 语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？</p>
<p>        就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p>
</blockquote>
<h4 id="2-6-5-SQL提示"><a href="#2-6-5-SQL提示" class="headerlink" title="2.6.5 SQL提示"></a><strong>2.6.5 SQL</strong>提示</h4><blockquote>
<p>  SQL 提示，是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。</p>
<p> 1). <strong>use index</strong> ： 建议 MySQL 使用哪一个索引完成此次查询（仅仅是建议， mysql 内部还会再次进行评估）。</p>
<p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> explain select * from tb_user use index(idx_user_pro) where profession = &#x27;软件工程&#x27;;<br></code></pre></td></tr></table></figure></p>
<p> 2). <strong>ignore index</strong> ： 忽略指定的索引。</p>
<p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;软件工程&#x27;;<br></code></pre></td></tr></table></figure></p>
<p> 3). force index ： 强制使用索引。</p>
<p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> explain select * from tb_user force index(idx_user_pro) where profession = &#x27;软件工程&#x27;;<br></code></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-6-6-覆盖索引"><a href="#2-6-6-覆盖索引" class="headerlink" title="2.6.6 覆盖索引"></a><strong>2.6.6</strong> <strong>覆盖索引</strong></h4><blockquote>
<p>尽量使用覆盖索引，减少 select * 。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p>
<p>接下来，我们来看一组 SQL 的执行计划，看看执行计划的差别，然后再来具体做一个解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id, profession from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27; ;<br>explain select id,profession,age, status from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27; ;<br>explain select id,profession,age, status, name from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27; ;<br>explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="../img/9debadb9f8894f81921412a75bc75577.png" srcset="/img/loading.gif" lazyload></p>
<p>从上述的执行计划我们可以看到，这四条 SQL 语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra ，前面两天 SQL 的结果为 <strong>Using</strong> <strong>where; Using Index</strong> ; 而后面两条 SQL 的结果为 : <strong>Using index condition</strong> 。</p>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where                       Using index</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td>
</tr>
<tr>
<td>Using Index                      condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<p>因为，在 tb_user 表中有一个联合索引 idx_user_pro_age_sta ，该索引关联了三个字段 profession、 age 、 status ，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id 。 所以当我们查询返回的数据在 id 、 profession 、 age 、 status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据 了，这个过程就是回表。 而我们如果一直使用 select * 查询返回所有字段值，很容易就会造成回表 查询（除非是根据主键查询，此时只会扫描聚集索引）。</p>
</blockquote>
<p> 思考题：</p>
<p>        一张表, 有四个字段 (id, username, password, status), 由于数据量大 , 需要对</p>
<p>以下 SQL 语句进行优化 , 该如何进行才是最优方案 :</p>
<p>        select id,username,password from tb_user where username = ‘itcast’;</p>
<p>        答案: 针对于 username, password <strong>建立联合索引</strong> ,</p>
<p>        sql为 : <strong>create index idx_user_name_pass on tb_user(username,password);</strong></p>
<p>        这样可以避免上述的SQL 语句，在查询的过程中，出现回表查询。</p>
<h4 id="2-6-7-前缀索引"><a href="#2-6-7-前缀索引" class="headerlink" title="2.6.7 前缀索引"></a><strong>2.6.7</strong> <strong>前缀索引</strong></h4><blockquote>
<p>当字段类型为字符串（ varchar ， text ， longtext 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO ， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p><strong>1). 语法</strong></p>
<ul>
<li>  <strong>create index</strong> idx_xxxx <strong>on</strong> table_name**(column(n)) ;**</li>
</ul>
<p>示例 :</p>
<p>为 tb_user 表的 email 字段，建立长度为 5 的前缀索引。</p>
<p>create index idx_email_5 on tb_user(email( 5 ));</p>
<p><strong>2). 前缀长度</strong></p>
<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1 ，这是最好的索引选择性，性能也是最好的。</p>
<ul>
<li>  <strong>select count(<strong><strong>distinct</strong> email</strong>)</strong> / <strong>count(*)</strong> <strong>from</strong> tb_user ;</li>
<li>  <strong>select count(distinct</strong> <strong>substring(<strong>email,1,5</strong>))</strong> / <strong>count</strong><strong>(*)</strong> <strong>from</strong> tb_user ;</li>
</ul>
<p><strong>3). 前缀索引的查询流程</strong></p>
<p><img src="../img/6b1c761bc71e405f88caf261955c5746.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="2-6-8-单列索引与联合索引"><a href="#2-6-8-单列索引与联合索引" class="headerlink" title="2.6.8 单列索引与联合索引"></a><strong>2.6.8</strong> <strong>单列索引与联合索引</strong></h4><blockquote>
<p><strong>单列索引：即一个索引只包含单个列。</strong></p>
<p><strong>联合索引：即一个索引包含了多个列。</strong></p>
<p><img src="../img/66bd0625ef424f599431f8f2a194d3a6.png" srcset="/img/loading.gif" lazyload></p>
<p>phone name 分别有一个单列索引</p>
<p><img src="../img/1f264bda198a46609c23d3646dad8116.png" srcset="/img/loading.gif" lazyload></p>
<p>Extra 为空说明发生了回表查询</p>
<p><img src="../img/2fd768ff1a89486587cc0abe4dd1d7ea.png" srcset="/img/loading.gif" lazyload></p>
<p>使用单列索引同时查询多个数据时只会用一个索引，同时进行徽标查询</p>
<p>使用联合索引可以避免回表查询</p>
<p>例： create unique index idx_user_phone_name on tb_user(phone,name);</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
</blockquote>
<h3 id="2-7-索引设计原则"><a href="#2-7-索引设计原则" class="headerlink" title="2.7 索引设计原则"></a><strong>2.7</strong> <strong>索引设计原则</strong></h3><blockquote>
<ul>
<li>  1). 针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>  2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li>
<li>  3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>  4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>  5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>  6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li>
<li>  7). 如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ul>
</blockquote>
<h2 id="3-SQL优化"><a href="#3-SQL优化" class="headerlink" title="3. SQL优化"></a>3. SQL优化</h2><h3 id="3-1-插入数据"><a href="#3-1-插入数据" class="headerlink" title="3.1 插入数据"></a><strong>3.1</strong> <strong>插入数据</strong></h3><h4 id="3-1-1-insert"><a href="#3-1-1-insert" class="headerlink" title="3.1.1 insert"></a><strong>3.1.1 insert</strong></h4><blockquote>
<p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into tb_test values(1,&#x27;tom&#x27;);<br>insert into tb_test values(2,&#x27;cat&#x27;);<br>insert into tb_test values(3,&#x27;jerry&#x27;);<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>1). 优化方案一</strong> </p>
<p>批量插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);<br></code></pre></td></tr></table></figure>

<p><strong>2). 优化方案二</strong>  </p>
<p>手动控制事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction;<br>insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);<br>insert into tb_test values(4,&#x27;Tom&#x27;),(5,&#x27;Cat&#x27;),(6,&#x27;Jerry&#x27;);<br>insert into tb_test values(7,&#x27;Tom&#x27;),(8,&#x27;Cat&#x27;),(9,&#x27;Jerry&#x27;);<br>commit;<br></code></pre></td></tr></table></figure>

<p> <strong>3). 优化方案三</strong></p>
<p>主键顺序插入，性能要高于乱序插入。</p>
<blockquote>
<p>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3</p>
<p>主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</p>
</blockquote>
<h4 id="3-1-2-大批量插入数据"><a href="#3-1-2-大批量插入数据" class="headerlink" title="3.1.2 大批量插入数据"></a><strong>3.1.2</strong> <strong>大批量插入数据</strong></h4><blockquote>
<p>如果一次性需要插入大批量数据 ( 比如 : 几百万的记录 ) ，使用 insert 语句插入性能较低，此时可以使用MySQL 数据库提供的 load 指令进行插入。操作如下：</p>
<p>先将本地文件数据上传至Linux：</p>
<p><img src="../img/e359309863f446dba4e56c14d95c0267.png" srcset="/img/loading.gif" lazyload></p>
<p>再复制其绝对路径</p>
<p><img src="../img/b66793b45cf849feb4b7ad98946f3f41.png" srcset="/img/loading.gif" lazyload></p>
<p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p>
<p>load data local infile ‘文件路径’ into table ‘表名’ fields terminated by ‘,’ lines terminated by ‘\n’</p>
<p>即将文件中数据导入表中，每个字段数据以“，”隔开，每行数据以换行隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 客户端连接服务端时，加上参数 -–local-infile<br>mysql –-local-infile -u root -p<br>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>-- 执行load指令将准备好的数据，加载到表结构中<br>load data local infile &#x27;/root/sql1.log&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ;<br></code></pre></td></tr></table></figure>

<p>主键顺序插入性能高于乱序插入</p>
</blockquote>
<h3 id="3-2-主键优化"><a href="#3-2-主键优化" class="headerlink" title="3.2 主键优化"></a><strong>3.2</strong> <strong>主键优化</strong></h3><blockquote>
<p>主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p>
</blockquote>
<ul>
<li>  1). 数据组织方式</li>
</ul>
<blockquote>
<p>在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p>
</blockquote>
<p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过 InnoDB 的逻辑结构图：</p>
<p><img src="../img/d487d9f252b34530bf396354dc6cc72e.png" srcset="/img/loading.gif" lazyload></p>
<p>在 InnoDB 引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认 16K 。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row 在该页存储不小将会存储到下一个页中，页与页之间会通过指针连接。</p>
<ul>
<li>  2). 页分裂</li>
</ul>
<blockquote>
<p>页可以为空，也可以填充一半，也可以填充 100% 。每个页包含了 2-N 行数据 ( 如果一行数据过大，会行溢出) ，根据主键排列。</p>
</blockquote>
<p> <strong>A. 主键顺序插入效果</strong></p>
<blockquote>
<p>① . 从磁盘中申请页， 主键顺序插入</p>
<p><img src="../img/d4cb25d93c894cadb8a0c75cf20eb497.png" srcset="/img/loading.gif" lazyload></p>
<p>② . 第一个页没有满，继续往第一页插入</p>
<p><img src="../img/87724fd44b5d4b26af108abf7789a32f.png" srcset="/img/loading.gif" lazyload></p>
<p>③ . 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p>
<p><img src="../img/eeb9009786684cb5a40dcd4d3ea7b2bc.png" srcset="/img/loading.gif" lazyload></p>
<p>④ . 当第二页写满了，再往第三页写入</p>
<p><img src="../img/5b584835d96c4efa977afbad8a58c8ca.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p><strong>B. 主键乱序插入效果</strong></p>
<blockquote>
<p>  ①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p>
<p> <img src="../img/02a897fea710431c891f6073c326d4e5.png" srcset="/img/loading.gif" lazyload></p>
<p> ② . 此时再插入 id 为 50 的记录，我们来看看会发生什么现象</p>
<p>         会再次开启一个页，写入新的页中吗？</p>
<p> 不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在 47 之后。</p>
<p> 但是 47 所在的 1# 页，已经写满了，存储不了 50 对应的数据了。 那么此时会开辟一个新的页</p>
<p> <img src="../img/c192c7de80f5408e9ca48f86962906f4.png" srcset="/img/loading.gif" lazyload></p>
<p> 但是并不会直接将 50 存入 3# 页，而是会将 1# 页后一半的数据，移动到 3# 页，然后在 3# 页，插入 50 。</p>
<p> <img src="../img/2e18cd60e0da46f9a2dcdb33f86430af.png" srcset="/img/loading.gif" lazyload></p>
<p> 移动数据，并插入 id 为 50 的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1# 的下一个页，应该是3# ， 3# 的下一个页是 2# 。 所以，此时，需要重新设置链表指针。</p>
<p> <img src="../img/45f82225ac36491cb8cd9280e8376c58.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>**上述的这种现象，称之为 “页分裂”**<strong>，是比较耗费性能的操作。</strong>  </p>
<ul>
<li>  3). 页合并</li>
</ul>
<blockquote>
<p>目前表中已有数据的索引结构 ( 叶子节点 ) 如下：</p>
<p><img src="../img/7553a253186044979694485609d44982.png" srcset="/img/loading.gif" lazyload></p>
<p> 当我们对已有数据进行删除时，具体的效果如下:</p>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（ flaged ）为删除并且它的空间变得允许被其他记录声明使用。</p>
<p><img src="../img/bdce47d9e2b9416ca783aa1f2e317c0a.png" srcset="/img/loading.gif" lazyload></p>
<p>当我们继续删除 2# 的数据记录</p>
<p><img src="../img/8019fb339f7349e681599e65387182d3.png" srcset="/img/loading.gif" lazyload></p>
<p>当页中删除的记录达到 MERGE_THRESHOLD （默认为页的 50% ）， InnoDB 会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
<p><img src="../img/ab20a689b8f54b36b4dbb229fa8aae5b.png" srcset="/img/loading.gif" lazyload></p>
<p>删除数据，并将页合并之后，再次插入新的数据 20 ，则直接插入 3# 页</p>
<p><img src="../img/fc24b97a43084a089fc01efad3759ad3.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p>
<p>知识小贴士：</p>
<p>MERGE_THRESHOLD ：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p>
<ul>
<li>  4). 索引设计原则</li>
</ul>
<blockquote>
<ul>
<li>  满足业务需求的情况下，尽量降低主键的长度。</li>
<li>  插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li>
<li>  尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
<li>  业务操作时，避免对主键的修改。</li>
</ul>
</blockquote>
<h3 id="3-3-order-by优化"><a href="#3-3-order-by优化" class="headerlink" title="3.3 order by优化"></a><strong>3.3 order by</strong>优化</h3><blockquote>
<p>MySQL 的排序，有两种方式：</p>
<p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort</p>
<p>buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p>
<p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index ，不需要</p>
<p>额外排序，操作效率高。</p>
<p>对于以上的两种排序方式， Using index 的性能高，而 Using filesort 的性能低，我们在优化排序操作时，尽量要优化为 Using index 。</p>
</blockquote>
<p> 接下来，我们来做一个测试：</p>
<ul>
<li>  执行排序SQL</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,age,phone from tb_user order by age ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/224461946d1c40f5972847e5e423b7fb.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,age,phone from tb_user order by age, phone ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/af04dc759a3c4f90821b31d325669f9d.png" srcset="/img/loading.gif" lazyload></p>
<p>由于 age, phone 都没有索引，所以此时再排序时，出现 Using filesort ， 排序性能较低</p>
</blockquote>
<ul>
<li>  创建索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建索引<br>create index idx_user_age_phone_aa on tb_user(age,phone);<br></code></pre></td></tr></table></figure>

<ul>
<li>  创建索引后，根据age, phone进行<strong>升序排序</strong></li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,age,phone from tb_user order by age;<br></code></pre></td></tr></table></figure>

<p><img src="../img/92bb9ef26cbc4dd581367fde7f916a8d.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age , phone;<br></code></pre></td></tr></table></figure>

<p><img src="../img/fd2ed8317afe44ccb77a40e9ccb47a09.png" srcset="/img/loading.gif" lazyload></p>
<p>建立索引之后，再次进行排序查询，就由原来的 Using filesort ， 变为了 Using index ，性能</p>
<p>就是比较高的了。</p>
</blockquote>
<ul>
<li>  创建索引后，根据age, phone进行<strong>降序排序</strong></li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,age,phone from tb_user order by age desc , phone desc ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/224acf58239c491a96b3e9402cdf2325.png" srcset="/img/loading.gif" lazyload></p>
<p>也出现 Using index ， 但是此时 Extra 中出现了 Backward index scan ，这个代表反向扫描索</p>
<p>引，因为在 MySQL 中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan 。 在MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p>
</blockquote>
<ul>
<li>   根据phone，age进行升序排序，phone在前，age在后。</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,age,phone from tb_user order by phone , age;<br></code></pre></td></tr></table></figure>

<p><img src="../img/7a1a37594e2f44378712e32789ee2b49.png" srcset="/img/loading.gif" lazyload></p>
<p>排序时 , 也需要满足最左前缀法则 , 否则也会出现 filesort 。因为在创建索引的时候， age 是第一个字段，phone 是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using</p>
<p>filesort 。</p>
</blockquote>
<ul>
<li>  根据age, phone进行降序一个升序，一个降序  </li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,age,phone from tb_user order by age asc , phone desc ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/277c6ea3b37b4f3dac3185c94846b7d2.png" srcset="/img/loading.gif" lazyload></p>
<p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort 。</p>
<p><img src="../img/ec1be9e95062499e82602d396aae546a.png" srcset="/img/loading.gif" lazyload></p>
<p>为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序， phone 倒序排序</p>
</blockquote>
<ul>
<li>   创建联合索引(age 升序排序，phone 倒序排序)</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);<br></code></pre></td></tr></table></figure>

<p><img src="../img/7ce8d4e73ad44a34b43c3f04affd5179.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<ul>
<li>   然后再次执行如下SQL</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,age,phone from tb_user order by age asc , phone desc ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/4e9f606d83534b38905e4403b8b66746.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>由上述的测试 , 我们得出 order by 优化原则 :</p>
<ul>
<li>  <strong>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</strong></li>
<li>  <strong>B. 尽量使用覆盖索引。</strong></li>
<li>  <strong>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</strong></li>
<li>  <strong>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小                         sort_buffer_size(默认256k)。</strong></li>
</ul>
<h3 id="3-4-group-by优化"><a href="#3-4-group-by优化" class="headerlink" title="3.4 group by优化"></a><strong>3.4 group by</strong>优化</h3><blockquote>
<p>分组操作，我们主要来看看索引对于分组操作的影响。</p>
<ul>
<li>  首先我们先将 tb_user 表的索引全部删除掉 。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop index idx_user_pro_age_sta on tb_user;<br>drop index idx_email_5 on tb_user;<br>drop index idx_user_age_phone_aa on tb_user;<br>drop index idx_user_age_phone_ad on tb_user;<br></code></pre></td></tr></table></figure>

<ul>
<li>  接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select profession , count(*) from tb_user group by profession ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/91e46e3646564e9bbf4c81bab7718c2e.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  然后，我们在针对于 profession ， age， status 创建一个联合索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index idx_user_pro_age_sta on tb_user(profession , age , status);<br></code></pre></td></tr></table></figure>

<ul>
<li>  再执行如下的分组查询SQL，查看执行计划：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select profession , count(*) from tb_user group by profession ;<br></code></pre></td></tr></table></figure>

<p><img src="../img/789778ca3e934f64b87fe7525381eef1.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="../img/e08af29826424fbc97e5660b0b8ff879.png" srcset="/img/loading.gif" lazyload></p>
<p>我们发现，如果仅仅根据 age 分组，就会出现 Using temporary ；而如果是根据</p>
<p>profession,age 两个字段同时分组，则不会出现 Using temporary 。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的。</p>
</blockquote>
<p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p>
<ul>
<li>  <strong>A. 在分组操作时，可以通过索引来提高效率。</strong></li>
<li>  <strong>B. 分组操作时，索引的使用也是满足最左前缀法则的。</strong></li>
</ul>
<h3 id="3-5-limit优化"><a href="#3-5-limit优化" class="headerlink" title="3.5 limit优化"></a><strong>3.5 limit</strong>优化</h3><blockquote>
<p>在数据量比较大时，如果进行 limit 分页查询，在查询时，越往后，分页查询效率越低。</p>
<p>我们一起来看看执行 limit 分页查询耗时对比：</p>
<p><img src="../img/b76f6ff34fb44421bba74a2c46e5a469.png" srcset="/img/loading.gif" lazyload> <img src="../img/0e228b86366c43c08f12b12680cd7235.png" srcset="/img/loading.gif" lazyload></p>
<p>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。</p>
<p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p>
</blockquote>
<p><strong>优化思路</strong> <strong>:</strong> 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查形式进行优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;<br></code></pre></td></tr></table></figure>

<p><img src="../img/0569a5dfcd104f18a4a5ee75c2e60c19.png" srcset="/img/loading.gif" lazyload></p>
<p>智能将子查询作为第二个表来匹配，不能作为id值返回</p>
<p><img src="../img/2c4156caac3f401697ef3fa940df3e94.png" srcset="/img/loading.gif" lazyload></p>
<p>因为MySQL不支持limit 在in中</p>
<h3 id="3-6-count优化"><a href="#3-6-count优化" class="headerlink" title="3.6 count优化"></a><strong>3.6 count</strong>优化</h3><h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a><strong>3.6.1</strong> <strong>概述</strong></h4><blockquote>
<p>select count(*) from tb_user ;</p>
<p>在之前的测试中，我们发现，如果数据量很大，在执行 count 操作时，是非常耗时的。</p>
<ul>
<li>  MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</li>
<li>  InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p>如果说要大幅度提升 InnoDB 表的 count 效率，主要的优化思路：自己计数 ( 可以借助于 redis 这样的数据库进行, 但是如果是带条件的 count 又比较麻烦了 ) 。</p>
</blockquote>
<h4 id="3-6-2-count用法"><a href="#3-6-2-count用法" class="headerlink" title="3.6.2 count用法"></a><strong>3.6.2 count</strong>用法</h4><blockquote>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是</p>
<p>NULL ，累计值就加 1 ，否则不加，最后返回累计值。</p>
<p>用法： <strong>count（*）、count（主键）、count（字段）、count（数字）</strong></p>
<table>
<thead>
<tr>
<th><strong>count</strong> <strong>用</strong> <strong>法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>count( 主键)</td>
<td>InnoDB 引擎会遍历整张表，把每一行的 主键 id 值都取出来，返回给服务层。</td>
</tr>
<tr>
<td>count( 字段)</td>
<td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null ，不为 null ，计数累加。有not null 约束： InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td>
</tr>
<tr>
<td>count( 数字)</td>
<td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字 “1” 进去，直接按行进行累加。</td>
</tr>
<tr>
<td>count(*)</td>
<td>InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</td>
</tr>
</tbody></table>
<p>按照效率排序的话， count( 字段 ) &lt; count( 主键 id) &lt; count(1) ≈ count(*) ，<strong>所以尽</strong></p>
<p><strong>量使用 count(*)。</strong></p>
</blockquote>
<h3 id="3-7-update优化"><a href="#3-7-update优化" class="headerlink" title="3.7 update优化"></a><strong>3.7 update</strong>优化</h3><blockquote>
<p>我们主要需要注意一下 update 语句执行时的注意事项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update course set name = &#x27;javaEE&#x27; where id = 1 ;<br></code></pre></td></tr></table></figure>

<p>当我们在执行更新的 SQL 语句时，会锁定 id 为 1 这一行的数据，然后事务提交之后，行锁释放。</p>
<p>但是当我们在执行如下 SQL 时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update course set name = &#x27;SpringBoot&#x27; where name = &#x27;PHP&#x27; ;<br></code></pre></td></tr></table></figure>

<p>当我们开启多个事务，在执行上述的 SQL 时，我们发现行锁升级为了表锁。 导致该 update 语句的性能大大降低。</p>
<p>因此在进行update时，追加条件的字段最好存在索引，可以更好的发挥事务的并发性</p>
</blockquote>
<p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁 , 并且该索引不能失效，否则会从行锁</p>
<p>升级为表锁 。</p>
<h2 id="4-视图-存储过程-触发器"><a href="#4-视图-存储过程-触发器" class="headerlink" title="4. 视图/存储过程/触发器"></a>4. 视图/存储过程/触发器</h2><h3 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a><strong>4.1</strong> <strong>视图</strong></h3><h4 id="4-1-1-介绍"><a href="#4-1-1-介绍" class="headerlink" title="4.1.1 介绍"></a><strong>4.1.1</strong> <strong>介绍</strong></h4><blockquote>
<p>视图（ View ）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<p>通俗的讲，视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL 查询语句上。</p>
</blockquote>
<h4 id="4-1-2-语法"><a href="#4-1-2-语法" class="headerlink" title="4.1.2 语法"></a><strong>4.1.2</strong> <strong>语法</strong></h4><p>1). 创建</p>
<blockquote>
<p>CREATE           [ OR REPLACE]         VIEW      视图名称 [( 列名列表 )]        AS       SELECT 语句 [ WITH    [ CASCADED    |    LOCAL ]    CHECK     OPTION ]</p>
</blockquote>
<p>2). 查询</p>
<blockquote>
<p>查看创建视图语句： SHOW    CREATE    VIEW    视图名称 ;</p>
<p>查看视图数据： SELECT   *    FROM    视图名称 …. .. ;</p>
</blockquote>
<p>3). 修改</p>
<blockquote>
<p>方式一： CREATE     [ OR REPLACE]     VIEW      视图名称 [( 列名列表 )]      AS   SELECT 语句 [ WITH     [ CASCADED    |    LOCAL ]    CHECK    OPTION ]</p>
<p>方式二： ALTER     VIEW     视图名称 [( 列名列表 )]    AS   SELECT 语句  [ WITH [ CASCADED |</p>
<p>LOCAL ] CHECK OPTION ]</p>
</blockquote>
<p>4). 删除</p>
<blockquote>
<p>DROP VIEW [IF EXISTS] 视图名称 [, 视图名称 ] …</p>
</blockquote>
<p>演示示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建视图<br>create or replace view stu_v_1 as select id,name from student where id &lt;= 10;<br>-- 查询视图<br>show create view stu_v_1;<br>select * from stu_v_1;<br>select * from stu_v_1 where id &lt; 3;<br>-- 修改视图<br>create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;<br>alter view stu_v_1 as select id,name from student where id &lt;= 10;<br>-- 删除视图<br>drop view if exists stu_v_1;<br></code></pre></td></tr></table></figure>

<p>上述我们演示了，视图应该如何创建、查询、修改、删除，那么我们能不能通过视图来插入、更新数据呢？ 接下来，做一个测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;<br>select * from stu_v_1;<br>insert into stu_v_1 values(6,&#x27;Tom&#x27;);<br>insert into stu_v_1 values(17,&#x27;Tom22&#x27;);<br></code></pre></td></tr></table></figure>

<p>执行上述的 SQL ，我们会发现， id 为 6 和 17 的数据都是可以成功插入的。 但是我们执行查询，查询出来的数据，却没有id 为 17 的记录。</p>
<p><img src="../img/06cbede265e841e3bd4c884fa7897c05.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>因为我们在创建视图的时候，指定的条件为 id&lt;=10, id 为 17 的数据，是不符合条件的，所以没有查</p>
<p>询出来，但是这条数据确实是已经成功的插入到了基表中。</p>
<p>如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p>
</blockquote>
<h4 id="4-1-3-检查选项"><a href="#4-1-3-检查选项" class="headerlink" title="4.1.3 检查选项"></a><strong>4.1.3</strong> <strong>检查选项</strong></h4><blockquote>
<p>当使用 WITH CHECK OPTION 子句创建视图时， MySQL 会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql 提供了两个选项： <strong>CASCADED</strong> 和 <strong>LOCAL</strong> ，默认值为 <strong>CASCADED</strong> 。</p>
<p>视图创建时加入检查选项会向下检查所有条件，而不会向上检查</p>
<p>如以下例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create or replace view stu_v_1 as select id,name from student where id &lt;= 20;<br><br>create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;= 10 with cascaded check option ;<br><br>create or replace view stu_v_3 as select id,name from stu_v_2 where id &lt;= 15 ;<br></code></pre></td></tr></table></figure>

<ul>
<li>  在第一个视图中，没有检查选项，任何id数据都可以插入</li>
<li>  在第二个视图中，是基于第一个视图创建的，在插入时首先检查是否满足id &gt;= 10，再向下检查是否满足id &lt;= 20。</li>
<li>  在第三个视图中，是基于第二个视图创建的，但是没有检查选项，因此不会检查条件    id &lt;=15，因此可以插入16，17，18，19，等数据,但由于第二个视图存在检查选项，会检查是否满足第二个视图的条件 id &gt;= 10，也会向下检查第一个视图条件id&lt;=20;</li>
</ul>
</blockquote>
<p><strong>1). CASCADED</strong></p>
<blockquote>
<p>级联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create or replace view stu_v_1 as select id,name from student where id &lt;= 20;<br><br>create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;= 10 with cascaded check option ;<br><br>create or replace view stu_v_3 as select id,name from stu_v_2 where id &lt;= 15 ;<br></code></pre></td></tr></table></figure>

<p>比如， v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 cascaded ，虽然 v1 视图创建时未指定检查选项。 但在执行检查时，不仅会检查v2 ，还会级联（向下）检查 v2 的关联视图 v1的条件 。</p>
</blockquote>
<p><strong>2). LOCAL</strong></p>
<blockquote>
<p>本地</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create or replace view stu_v_1 as select id,name from student where id &lt;= 20;<br><br>create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;= 10 with local check option ;<br><br>create or replace view stu_v_3 as select id,name from stu_v_2 where id &lt;= 15 ;<br></code></pre></td></tr></table></figure>

<p>比如， v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 local ，但是 v1 视图创建时未指定检查选项。 则在执行检查时，只会检查v2 ，不会检查 v2 的关联视图 v1 。</p>
</blockquote>
<h4 id="4-1-4-视图的更新"><a href="#4-1-4-视图的更新" class="headerlink" title="4.1.4 视图的更新"></a><strong>4.1.4</strong> <strong>视图的更新</strong></h4><blockquote>
<p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p>
<ul>
<li>  A. <strong>聚合函数或窗口函数</strong>（SUM()、 MIN()、 MAX()、 COUNT()等）</li>
<li>  B. DISTINCT（distinct）</li>
<li>  C. GROUP BY（group by)</li>
<li>  D. HAVING（having）</li>
<li>  E. UNION 或者 UNION ALL</li>
</ul>
</blockquote>
<h4 id="4-1-5-视图作用"><a href="#4-1-5-视图作用" class="headerlink" title="4.1.5 视图作用"></a><strong>4.1.5</strong> <strong>视图作用</strong></h4><blockquote>
<p><strong>1). 简单</strong></p>
<p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p>
<p><strong>2). 安全</strong></p>
<p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p>
<p><strong>3). 数据独立</strong></p>
<p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p>
</blockquote>
<h4 id="4-1-6-案例"><a href="#4-1-6-案例" class="headerlink" title="4.1.6 案例"></a><strong>4.1.6</strong> <strong>案例</strong></h4><blockquote>
<p><strong>1).</strong> 为了保证数据库表的安全性，开发人员在操作 tb_user 表时，只能看到的用户的基本字段，<strong>屏蔽手机号和邮箱两个字段。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create view tb_user_view as<br>select id, name, profession, age, gender, status, createtime<br>from tb_user;<br><br>select *<br>from tb_user_view;<br></code></pre></td></tr></table></figure>

<p><img src="../img/6ab4b8c96d984129b0060875a3c25321.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>2).</strong> 查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create view tb_stu_course_view as<br>select s.name student_name, s.no student_no, c.name course_name<br>from student s,<br>  student_course sc,<br>  course c<br>where s.id = sc.studentid<br>and sc.courseid = c.id;<br><br>select *<br>from tb_stu_course_view;<br></code></pre></td></tr></table></figure>

<p><img src="../img/5478c174a67442eb9dbdcb7f73246230.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="4-2-存储过程"><a href="#4-2-存储过程" class="headerlink" title="4.2 存储过程"></a><strong>4.2</strong> <strong>存储过程</strong></h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a><strong>4.2.1</strong> <strong>介绍</strong></h4><blockquote>
<p>                存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>
<p>        <img src="../img/b5fda1ae0153483ea5672659bf23481f.png" srcset="/img/loading.gif" lazyload></p>
<p>        <strong>特点:</strong></p>
<p>        *   封装，复用 ———————————–&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。<br>        *   可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回值。<br>        *   减少网络交互，效率提升 —————–&gt; 如果涉及到多条SQL，每执行一次都是一次网络传 输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p>
</blockquote>
<h4 id="4-2-2-基本语法"><a href="#4-2-2-基本语法" class="headerlink" title="4.2.2 基本语法"></a><strong>4.2.2</strong> <strong>基本语法</strong></h4><blockquote>
<p><strong>1). 创建</strong></p>
<p>CREATE   PROCEDURE   存储过程名称 ([ 参数列表 ])</p>
<p>BEGIN</p>
<p>        – SQL语句</p>
<p>END ;</p>
<p><strong>2). 调用</strong></p>
<p>CALL   名称   ([ 参数 ]);</p>
<p><strong>3). 查看</strong></p>
<p>SELECT * FROM   INFORMATION_SCHEMA .ROUTINES   WHERE   ROUTINE_SCHEMA = ‘xxx’ ; -- 查询指定数据库的存储过程及状态信息</p>
<p>SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</p>
<p><strong>4). 删除</strong></p>
<p>DROP   PROCEDURE  [ IF EXISTS ]   存储过程名称 ；</p>
<p><strong>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的</strong></p>
<p><strong>结束符。</strong></p>
</blockquote>
<p>演示示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 存储过程基本语法<br>-- 创建<br>create procedure p1()<br>begin<br>select count(*) from student;<br>end;<br>-- 调用<br>call p1();<br>-- 查看<br>select * from information_schema.ROUTINES where ROUTINE_SCHEMA = &#x27;itcast&#x27;;<br>show create procedure p1;<br>-- 删除<br>drop procedure if exists p1;<br></code></pre></td></tr></table></figure>

<h4 id="4-2-3-变量"><a href="#4-2-3-变量" class="headerlink" title="4.2.3 变量"></a><strong>4.2.3</strong> <strong>变量</strong></h4><blockquote>
<p>在 MySQL 中变量分为三种类型 : 系统变量、用户定义变量、局部变量。</p>
</blockquote>
<h5 id="4-2-3-1-系统变量"><a href="#4-2-3-1-系统变量" class="headerlink" title="4.2.3.1 系统变量"></a><strong>4.2.3.1</strong> <strong>系统变量</strong></h5><blockquote>
<p>系统变量 是 MySQL 服务器提供，不是用户定义的，属于服务器层面。分为全局变量（ GLOBAL ）、会话变量（SESSION ）。</p>
<p><strong>1). 查看系统变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量<br>SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#x27;......&#x27;; -- 可以通过LIKE模糊匹配方式查找变量<br>SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值<br></code></pre></td></tr></table></figure>

<p><strong>2). 设置系统变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;<br>SET @@[SESSION | GLOBAL]系统变量名 = 值 ;<br></code></pre></td></tr></table></figure>

<p>注意 :</p>
<p>        如果没有指定SESSION/GLOBAL ，默认是 SESSION ，会话变量。</p>
<p>        mysql 服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。</p>
<ul>
<li>  A. 全局变量(GLOBAL): 全局变量针对于所有的会话。</li>
<li>  B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</li>
</ul>
</blockquote>
<p>演示示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查看系统变量<br>show session variables ;<br>show session variables like &#x27;auto%&#x27;;<br>show global variables like &#x27;auto%&#x27;;<br>select @@global.autocommit;<br>select @@session.autocommit;<br>-- 设置系统变量<br>set session autocommit = 1;<br>insert into course(id, name) VALUES (6, &#x27;ES&#x27;);<br>set global autocommit = 0;<br>select @@global.autocommit;<br></code></pre></td></tr></table></figure>

<h5 id="4-2-3-2-用户定义变量"><a href="#4-2-3-2-用户定义变量" class="headerlink" title="4.2.3.2 用户定义变量"></a><strong>4.2.3.2</strong> <strong>用户定义变量</strong></h5><blockquote>
<p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@ 变量名” 使用就可以。其作用域为当前连接。</p>
<p><strong>1). 赋值</strong></p>
<p>方式一 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @var_name = expr [, @var_name = expr] ... ;<br>SET @var_name := expr [, @var_name := expr] ... ;<br></code></pre></td></tr></table></figure>

<p>赋值时，可以使用’  = ‘ ，也可以使用 ‘ :=’  。</p>
<p><strong>注：在MySQL中‘=’既可以是比较运算符，也可以是赋值运算符，而‘:=’为赋值运算符</strong></p>
<p>方式二 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @var_name := expr [, @var_name := expr] ... ;<br>SELECT 字段名 INTO @var_name FROM 表名;<br></code></pre></td></tr></table></figure>

<p>2). 使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @var_name ;<br></code></pre></td></tr></table></figure>

<p>注意 : 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为 NULL 。</p>
</blockquote>
<p>演示示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 赋值<br>set @myname = &#x27;itcast&#x27;;<br>set @myage := 10;<br>set @mygender := &#x27;男&#x27;,@myhobby := &#x27;java&#x27;;<br>select @mycolor := &#x27;red&#x27;;<br>select count(*) into @mycount from tb_user;<br>-- 使用<br>select @myname,@myage,@mygender,@myhobby;<br>select @mycolor , @mycount;<br>select @abc;<br></code></pre></td></tr></table></figure>

<h5 id="4-2-3-3-局部变量"><a href="#4-2-3-3-局部变量" class="headerlink" title="4.2.3.3 局部变量"></a><strong>4.2.3.3</strong> <strong>局部变量</strong></h5><blockquote>
<p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END 块。</p>
<p><strong>1). 声明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE 变量名 变量类型 [DEFAULT ... ] ;<br></code></pre></td></tr></table></figure>

<p>变量类型就是数据库字段类型： INT 、 BIGINT 、 CHAR 、 VARCHAR 、 DATE 、 TIME 等。 </p>
<p><strong>2). 赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET 变量名 = 值 ;<br>SET 变量名 := 值 ;<br>SELECT 字段名 INTO 变量名 FROM 表名 ... ;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>演示示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 声明局部变量 - declare<br>-- 赋值<br>create procedure p2()<br>begin<br>declare stu_count int default 0;<br>select count(*) into stu_count from student;<br>select stu_count;<br>end;<br>call p2();<br></code></pre></td></tr></table></figure>

<h4 id="4-2-4-if"><a href="#4-2-4-if" class="headerlink" title="4.2.4 if"></a><strong>4.2.4 if</strong></h4><blockquote>
<p>1). 介绍</p>
<p>if 用于做条件判断，具体的语法结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF 条件1 THEN<br>.....<br>ELSEIF 条件2 THEN -- 可选<br>.....<br>ELSE -- 可选<br>.....<br>END IF;<br></code></pre></td></tr></table></figure>

<p>在 if 条件判断的结构中， ELSE IF 结构可以有多个，也可以没有。 ELSE 结构可以有，也可以没有。</p>
<p>2). 案例</p>
<p>根据定义的分数 score 变量，判定当前分数对应的分数等级。</p>
<ul>
<li>  score &gt;= 85分，等级为优秀。</li>
<li>  score &gt;= 60分 且 score &lt; 85分，等级为及格。</li>
<li>  score &lt; 60分，等级为不及格。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p3()<br>begin<br>    declare score int default 58;<br>    declare result varchar(10);<br><br>    if score &gt;= 85 then<br>        set result := &#x27;优秀&#x27;;<br>    elseif score &gt;= 60 then<br>        set result := &#x27;及格&#x27;;<br>    else<br>        set result := &#x27;不及格&#x27;;<br>    end if;<br>    select result;<br>end;<br>call p3();<br></code></pre></td></tr></table></figure>

<p>上述的需求我们虽然已经实现了，但是也存在一些问题，比如： score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。</p>
<p>那么我们能不能，把 score 分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？答案是肯定的，我们可以通过接下来所讲解的<strong>参数</strong>来解决上述的问题。</p>
</blockquote>
<h4 id="4-2-5-参数"><a href="#4-2-5-参数" class="headerlink" title="4.2.5 参数"></a><strong>4.2.5</strong> <strong>参数</strong></h4><blockquote>
<p><strong>1). 介绍</strong></p>
<p>参数的类型，主要分为以下三种： IN 、 OUT 、 INOUT 。 具体的含义如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody></table>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])<br>BEGIN<br> -- SQL语句<br>END ;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>2). 案例一</strong></p>
<p>根据传入参数 score ，判定当前分数对应的分数等级，并返回。</p>
<ul>
<li>  score &gt;= 85分，等级为优秀。</li>
<li>  score &gt;= 60分 且 score &lt; 85分，等级为及格。</li>
<li>  score &lt; 60分，等级为不及格。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p4(in score int, out result varchar(10))<br>begin<br>    if score &gt;= 85 then<br>        set result := &#x27;优秀&#x27;;<br>    elseif score &gt;= 60 then<br>        set result := &#x27;及格&#x27;;<br>    else<br>        set result := &#x27;不及格&#x27;;<br>    end if;<br>end;<br>-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明<br>call p4(18, @result);<br>select @result;<br></code></pre></td></tr></table></figure>

<p><strong>3). 案例二</strong></p>
<p>将 <strong>传入</strong> 的 200 分制的分数，进行换算，换算成百分制，然后 <strong>返回</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p5(inout score double)<br>begin<br>    set score := score * 0.5;<br>end;<br>set @score = 198;<br>call p5(@score);<br>select @score;<br></code></pre></td></tr></table></figure>

<h4 id="4-2-6-case"><a href="#4-2-6-case" class="headerlink" title="4.2.6 case"></a><strong>4.2.6 case</strong></h4><blockquote>
<p>1). 介绍</p>
<p>case 结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：</p>
<p>语法 1 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，<br>执行statement_list2， 否则就执行 statement_list<br>CASE case_value<br> WHEN when_value1 THEN statement_list1<br> [ WHEN when_value2 THEN statement_list2] ...<br> [ ELSE statement_list ]<br>END CASE;<br></code></pre></td></tr></table></figure>

<p>语法 2 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成<br>立时，执行statement_list2， 否则就执行 statement_list<br>CASE<br> WHEN search_condition1 THEN statement_list1<br> [WHEN search_condition2 THEN statement_list2] ...<br> [ELSE statement_list]<br>END CASE;<br></code></pre></td></tr></table></figure>

<p>2). 案例</p>
<p>根据传入的月份，判定月份所属的季节（要求采用 case 结构）。</p>
<ul>
<li>  1-3月份，为第一季度</li>
<li>  4-6月份，为第二季度</li>
<li>  7-9月份，为第三季度</li>
<li>  10-12月份，为第四季度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p6(in month int)<br>begin<br>    declare result varchar(10);<br>    case<br>        when month &gt;= 1 and month &lt;= 3 then<br>            set result := &#x27;第一季度&#x27;;<br>        when month &gt;= 4 and month &lt;= 6 then<br>            set result := &#x27;第二季度&#x27;;<br>        when month &gt;= 7 and month &lt;= 9 then<br>            set result := &#x27;第三季度&#x27;;<br>        when month &gt;= 10 and month &lt;= 12 then<br>            set result := &#x27;第四季度&#x27;;<br>        else<br>            set result := &#x27;非法参数&#x27;;<br>    end case ;<br><br>    select concat(&#x27;您输入的月份为: &#x27;,month, &#x27;, 所属的季度为: &#x27;,result);<br>end;<br><br>call p6(16);<br></code></pre></td></tr></table></figure>

<p>注意：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p>
</blockquote>
<h4 id="4-2-7-while"><a href="#4-2-7-while" class="headerlink" title="4.2.7 while"></a><strong>4.2.7 while</strong></h4><blockquote>
<p>1). 介绍</p>
<p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的 SQL 语句。具体语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑<br>WHILE 条件 DO<br> SQL逻辑...<br>END WHILE;<br></code></pre></td></tr></table></figure>

<p>2). 案例</p>
<p>计算从 1 累加到 n 的值， n 为传入的参数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- A. 定义局部变量, 记录累加之后的值;<br>-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环<br>create procedure p7(in n int)<br>begin<br> declare total int default 0;<br> while n&gt;0 do<br>     set total := total + n;<br>     set n := n - 1;<br> end while;<br><br> select total;<br>end;<br><br>call p7(100);<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-2-8-repeat"><a href="#4-2-8-repeat" class="headerlink" title="4.2.8 repeat"></a><strong>4.2.8 repeat</strong></h4><blockquote>
<p><strong>1). 介绍</strong></p>
<p>repeat 是有条件的循环控制语句 , 当满足 until 声明的条件的时候，则退出循环 。具体语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环<br>REPEAT<br> SQL逻辑...<br> UNTIL 条件<br>END REPEAT;<br></code></pre></td></tr></table></figure>

<p>2). 案例</p>
<p>计算从 1 累加到 n 的值， n 为传入的参数值。 ( 使用 repeat 实现 )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- A. 定义局部变量, 记录累加之后的值;<br>-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环<br>create procedure p8(in n int)<br>begin<br> declare total int default 0;<br> repeat<br>     set total := total + n;<br>     set n := n - 1;<br> until n &lt;= 0<br> end repeat;<br> select total;<br>end;<br><br>call p8(10);<br>call p8(100);<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-2-9-loop"><a href="#4-2-9-loop" class="headerlink" title="4.2.9 loop"></a><strong>4.2.9 loop</strong></h4><blockquote>
<p>1). 介绍</p>
<p>LOOP 实现简单的循环，如果不在 SQL 逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合一下两个语句使用：</p>
<ul>
<li>  LEAVE ：配合循环使用，退出循环。</li>
<li>  ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[begin_label:] LOOP<br>    SQL逻辑...<br>END LOOP [end_label];<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LEAVE label; -- 退出指定标记的循环体<br>ITERATE label; -- 直接进入下一次循环<br></code></pre></td></tr></table></figure>

<p>上述语法中出现的 begin_label ， end_label ， label 指的都是我们所自定义的标记。</p>
</blockquote>
<p>2). 案例一</p>
<p>计算从 1 累加到 n 的值， n 为传入的参数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- A. 定义局部变量, 记录累加之后的值;<br>-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx<br>create procedure p9(in n int)<br>begin<br>    declare total int default 0;<br>    sum:loop<br>        if n&lt;=0 then<br>            leave sum;<br>        end if;<br>        set total := total + n;<br>        set n := n - 1;<br>    end loop sum;<br><br>    select total;<br>end;<br><br>call p9(100);<br></code></pre></td></tr></table></figure>

<p>2). 案例一</p>
<p>计算从 1 累加到 n 的值， n 为传入的参数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- A. 定义局部变量, 记录累加之后的值;<br>-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx<br>-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xx<br>create procedure p10(in n int)<br>begin<br>    declare total int default 0;<br><br>    sum:loop<br>        if n&lt;=0 then<br>            leave sum;<br>        end if;<br><br>        if n%2 = 1 then<br>            set n := n - 1;<br>            iterate sum;<br>        end if;<br><br>        set total := total + n;<br>        set n := n - 1;<br><br>    end loop sum;<br>    select total;<br>end;<br><br>call p10(100);<br></code></pre></td></tr></table></figure>

<h4 id="4-2-10-游标"><a href="#4-2-10-游标" class="headerlink" title="4.2.10 游标"></a><strong>4.2.10</strong> <strong>游标</strong></h4><blockquote>
<p>1). 介绍</p>
<p>游标（ CURSOR ）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN 、 FETCH 和 CLOSE ，其语法分别如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 声明游标<br>DECLARE 游标名称 CURSOR FOR 查询语句 ;<br><br>-- 打开游标<br>OPEN 游标名称 ;<br><br>-- 获取游标记录<br>FETCH 游标名称 INTO 变量 [, 变量 ] ;<br><br>关闭游标<br>CLOSE 游标名称 ;<br><br></code></pre></td></tr></table></figure>

<p>2). 案例</p>
<p>根据传入的参数 uage ，来查询用户表 tb_user 中，所有的用户年龄小于等于 uage 的用户姓名</p>
<p>（ name ）和专业（ profession ），并将用户的姓名和专业插入到所创建的一张新表</p>
<p>(id,name,profession) 中。</p>
<p>-- 逻辑 :</p>
<ul>
<li><p>  -- A. 声明游标, 存储查询结果集</p>
</li>
<li><p>  -- B. 准备: 创建表结构</p>
</li>
<li><p>  -- C. 开启游标</p>
</li>
<li><p>  -- D. 获取游标中的记录</p>
</li>
<li><p>  -- E. 插入数据到新表中</p>
</li>
<li><p>  -- F. 关闭游标</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p11(in uage int)<br>begin<br>    declare uname varchar(100);<br>    declare upro varchar(100);<br>    declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;<br><br>    drop table if exists tb_user_pro;<br>    create table if not exists tb_user_pro(<br>        id int primary key auto_increment,<br>        name varchar(100),<br>        profession varchar(100)<br>    );<br><br>    open u_cursor;<br>    while true do<br>        fetch u_cursor into uname,upro;<br>        insert into tb_user_pro values (null, uname, upro);<br>    end while;<br>    close u_cursor;<br><br>end;<br><br>call p11(30);<br></code></pre></td></tr></table></figure>

<p>        上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while 循环中，并没有退出条件。<strong>当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。</strong></p>
<p>        但是此时，tb_user_pro 表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。</p>
<p>        上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题</p>
</blockquote>
<h4 id="4-2-11-条件处理程序"><a href="#4-2-11-条件处理程序" class="headerlink" title="4.2.11 条件处理程序"></a><strong>4.2.11</strong> <strong>条件处理程序</strong></h4><blockquote>
<p><strong>1). 介绍</strong></p>
<p>条件处理程序（ Handler ）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p>
<p>DECLARE handler_action HANDLER FOR condition_value [, condition_value] … statement;</p>
<p><strong>handler_action</strong> 的取值：</p>
<p>        CONTINUE: 继续执行当前程序</p>
<p>        EXIT: 终止执行当前程序</p>
<p><strong>condition_value</strong> 的取值：</p>
<p>        SQLSTATE sqlstate_value: 状态码，如 02000</p>
<p>        SQLWARNING: 所有以 01 开头的 SQLSTATE 代码的简写</p>
<p>        NOT FOUND: 所有以 02 开头的 SQLSTATE 代码的简写</p>
<p>        SQLEXCEPTION: 所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的简写</p>
<p><strong>2). 案例</strong></p>
<p>我们继续来完成在上一小节提出的这个需求，并解决其中的问题。</p>
<p>根据传入的参数 uage ，来查询用户表 tb_user 中，所有的用户年龄小于等于 uage 的用户姓名</p>
<p>（ name ）和专业（ profession ），并将用户的姓名和专业插入到所创建的一张新表</p>
<p>(id,name,profession) 中。</p>
<p>A. 通过 SQLSTATE 指定具体的状态码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p11(in uage int)<br>begin<br> declare uname varchar(100);<br> declare upro varchar(100);<br> declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;<br><br>-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出<br> declare exit handler for SQLSTATE &#x27;02000&#x27; close u_cursor;<br><br> drop table if exists tb_user_pro;<br> create table if not exists tb_user_pro(<br>     id int primary key auto_increment,<br>     name varchar(100),<br>     profession varchar(100)<br> );<br><br> open u_cursor;<br> while true do<br>     fetch u_cursor into uname,upro;<br>     insert into tb_user_pro values (null, uname, upro);<br> end while;<br><br>close u_cursor;<br>end;<br>call p11(30);<br></code></pre></td></tr></table></figure>

<p>B. 通过 SQLSTATE 的代码简写方式 NOT FOUND</p>
<p>02 开头的状态码，代码简写为 <strong>NOT FOUND</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p12(in uage int)<br>begin<br> declare uname varchar(100);<br> declare upro varchar(100);<br> declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;<br><br>-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出<br> declare exit handler for not found close u_cursor;<br><br> drop table if exists tb_user_pro;<br> create table if not exists tb_user_pro(<br>     id int primary key auto_increment,<br>     name varchar(100),<br>     profession varchar(100)<br> );<br><br> open u_cursor;<br> while true do<br>     fetch u_cursor into uname,upro;<br>     insert into tb_user_pro values (null, uname, upro);<br> end while;<br><br> close u_cursor;<br>end;<br>call p12(30);<br></code></pre></td></tr></table></figure>

<p>具体的错误状态码，可以参考官方文档：</p>
<p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a></strong></p>
</blockquote>
<h3 id="4-3-存储函数"><a href="#4-3-存储函数" class="headerlink" title="4.3 存储函数"></a><strong>4.3</strong> <strong>存储函数</strong></h3><blockquote>
<p>1). 介绍</p>
<p>存储函数是有返回值的存储过程，存储函数的参数只能是 IN 类型的。具体语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION 存储函数名称 ([ 参数列表 ])<br>RETURNS type [characteristic ...]<br>BEGIN<br> -- SQL语句<br> RETURN ...;<br>END ;<br></code></pre></td></tr></table></figure>

<p>characteristic 说明：</p>
<ul>
<li><p>  DETERMINISTIC：相同的输入参数总是产生相同的结果</p>
</li>
<li><p>  NO SQL ：不包含 SQL 语句。</p>
</li>
<li><p>  READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</p>
</li>
</ul>
<p>2). 案例</p>
<p>计算从 1 累加到 n 的值， n 为传入的参数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create function fun1(n int)<br>returns int deterministic<br>begin<br>    declare total int default 0;<br><br>    while n&gt;0 do<br>        set total := total + n;<br>        set n := n - 1;<br>    end while;<br><br>    return total;<br>end;<br><br>select fun1(50);<br></code></pre></td></tr></table></figure>

<p><strong>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报错</strong></p>
</blockquote>
<h3 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a><strong>4.4</strong> <strong>触发器</strong></h3><h4 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a><strong>4.4.1</strong> <strong>介绍</strong></h4><blockquote>
<p>触发器是与表有关的数据库对象，指在 <strong>insert/update/delete</strong> 之前 <strong>(BEFORE)</strong> 或之后 <strong>(AFTER)</strong> ，触发并执行触发器中定义的SQL 语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。</p>
<p>使用别名 <strong>OLD</strong> 和 <strong>NEW</strong> 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW和OLD</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="4-4-2-语法"><a href="#4-4-2-语法" class="headerlink" title="4.4.2 语法"></a><strong>4.4.2</strong> <strong>语法</strong></h4><blockquote>
<p>1). 创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER trigger_name<br>BEFORE/AFTER INSERT/UPDATE/DELETE ON tbl_name FOR EACH ROW -- 行级触发器<br>BEGIN<br> trigger_stmt ;<br>END;<br></code></pre></td></tr></table></figure>

<p>2). 查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS ;<br></code></pre></td></tr></table></figure>

<p>3). 删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TRIGGER [schema_name.]trigger_name ; <br>-- 如果没有指定 schema_name，默认为当前数据库 。<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-4-3-案例"><a href="#4-4-3-案例" class="headerlink" title="4.4.3 案例"></a><strong>4.4.3</strong> <strong>案例</strong></h4><blockquote>
<p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表 user_logs 中 , 包含增加 ,修改 , 删除 ;</p>
<p>表结构准备 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 准备工作 : 日志表 user_logs<br>create table user_logs(<br> id int(11) not null auto_increment,<br> operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;,<br> operate_time datetime not null comment &#x27;操作时间&#x27;,<br> operate_id int(11) not null comment &#x27;操作的ID&#x27;,<br> operate_params varchar(500) comment &#x27;操作参数&#x27;,<br> primary key(`id`)<br>)engine=innodb default charset=utf8;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>A. 插入数据触发器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create trigger tb_user_insert_trigger<br>after insert on tb_user for each row<br>    begin<br>        insert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES<br>        (null, &#x27;insert&#x27;, now(), new.id, concat(&#x27;插入的数据内容为:<br>        id=&#x27;,new.id,&#x27;,name=&#x27;,new.name, &#x27;, phone=&#x27;, NEW.phone, <br>        &#x27;, email=&#x27;, NEW.email, &#x27;,profession=&#x27;, NEW.profession));<br>end;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 插入数据到tb_user<br>insert into tb_user(id, name, phone, email, profession, age, gender, status,createtime)<br>VALUES (26,&#x27;三皇子&#x27;,&#x27;18809091212&#x27;,&#x27;erhuangzi@163.com&#x27;,&#x27;软件工程&#x27;,23,&#x27;1&#x27;,&#x27;1&#x27;,now());<br></code></pre></td></tr></table></figure>

<p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p>
<p> <strong>B. 修改数据触发器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create trigger tb_user_update_trigger<br>    after update on tb_user for each row<br>    begin<br>        insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES<br>        (null, &#x27;update&#x27;, now(), new.id,concat(&#x27;更新之前的数据: id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,<br>                                              &#x27;, phone=&#x27;,old.phone, &#x27;, email=&#x27;, old.email, &#x27;, profession=&#x27;, old.profession,<br>                                              &#x27; | 更新之后的数据: id=&#x27;,new.id,&#x27;,name=&#x27;,new.name, &#x27;, phone=&#x27;,NEW.phone,<br>                                              &#x27;, email=&#x27;, NEW.email, &#x27;, profession=&#x27;, NEW.profession));<br>    end;<br></code></pre></td></tr></table></figure>

<p> 测试:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update tb_user set profession = &#x27;会计&#x27; where id = 23;<br>update tb_user set profession = &#x27;会计&#x27; where id &lt;= 5;<br><br></code></pre></td></tr></table></figure>

<p> 测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p>
<p><img src="../img/bdb9b7fad9e3482ead2f46f64c398f9e.png" srcset="/img/loading.gif" lazyload></p>
<p> <strong>C. 删除数据触发器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create trigger tb_user_delete_trigger<br>    after delete<br>    on tb_user<br>    for each row<br>begin<br>    insert into user_logs(id, operation, operate_time, operate_id, operate_params)<br>    VALUES (null, &#x27;delete&#x27;, now(), old.id,<br>            concat(&#x27;删除之前的数据: id=&#x27;, old.id, &#x27;,name=&#x27;, old.name, &#x27;, phone=&#x27;,<br>                   old.phone, &#x27;, email=&#x27;, old.email, &#x27;, profession=&#x27;, old.profession));<br>end;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 删除数据<br>delete from tb_user where id = 26;<br></code></pre></td></tr></table></figure>

<p> <img src="../img/ac4b19a9facb414b8c55da6a55d458dd.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="5-锁"><a href="#5-锁" class="headerlink" title="5. 锁"></a>5. 锁</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a><strong>5.1</strong> <strong>概述</strong></h3><blockquote>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（ CPU 、RAM、 I/O ）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL 中的锁，按照锁的粒度分，分为以下三类：</p>
<ul>
<li>  全局锁：锁定数据库中的所有表。</li>
<li>  表级锁：每次操作锁住整张表。</li>
<li>  行级锁：每次操作锁住对应的行数据。</li>
</ul>
</blockquote>
<h3 id="5-2-全局锁"><a href="#5-2-全局锁" class="headerlink" title="5.2 全局锁"></a><strong>5.2</strong> <strong>全局锁</strong></h3><h4 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a><strong>5.2.1</strong> <strong>介绍</strong></h4><blockquote>
<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句， DDL 语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>为什么全库逻辑备份，就需要加全就锁呢？</p>
</blockquote>
<p><strong>A.</strong> <strong>我们一起先来分析一下不加全局锁，可能存在的问题。</strong></p>
<p>    假设在数据库中存在这样三张表: tb_stock 库存表， tb_order 订单表， tb_orderlog 订单日志表。</p>
<p><img src="../img/a4371ebb50d74286afcaa26a7ed3c682.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  在进行数据备份时，先备份了tb_stock库存表。</li>
<li>  然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li>
<li>  然后再执行备份 tb_order表的逻辑。</li>
<li>  业务中执行插入订单日志操作。</li>
<li>  最后，又备份了tb_orderlog表。</li>
</ul>
<p>此时备份出来的数据，是存在问题的。因为备份出来的数据， tb_stock 表与 tb_order 表的数据不一</p>
<p>致 ( 有最新操作的订单信息 , 但是库存数没减 ) 。</p>
<p>那如何来规避这种问题呢 ? 此时就可以借助于 MySQL 的全局锁来解决。</p>
<p><strong>B. 再来分析一下加了全局锁后的情况</strong></p>
<p><img src="../img/180d21f96f834769ae6cab59fba1c0ae.png" srcset="/img/loading.gif" lazyload></p>
<p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的 DDL 、DML全部都处于阻塞状态，但是可以执行 DQL 语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p>
<h4 id="5-2-2-语法"><a href="#5-2-2-语法" class="headerlink" title="5.2.2 语法"></a><strong>5.2.2</strong> <strong>语法</strong></h4><blockquote>
<p>1). 加全局锁</p>
<p><strong>flush tables with read lock ;</strong></p>
<p>2). 数据备份</p>
<p><strong>mysqldump -uroot –p1234 itcast &gt; itcast.sql</strong></p>
<p>数据备份的相关指令 , 在后面 MySQL 管理章节 , 还会详细讲解 .</p>
<p>3). 释放锁</p>
<p><strong>unlock tables ;</strong></p>
</blockquote>
<h4 id="5-2-3-特点"><a href="#5-2-3-特点" class="headerlink" title="5.2.3 特点"></a><strong>5.2.3</strong> <strong>特点</strong></h4><blockquote>
<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<ul>
<li>  如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>  如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ul>
<p>在 InnoDB 引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致</p>
<p>性数据备份。</p>
<p><strong>mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</strong></p>
</blockquote>
<h3 id="5-3-表级锁"><a href="#5-3-表级锁" class="headerlink" title="5.3 表级锁"></a><strong>5.3</strong> <strong>表级锁</strong></h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="**5.3.1 **介绍"></a>**5.3.1 **介绍</h4><blockquote>
<p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM 、InnoDB、 BDB 等存储引擎中。</p>
<p>对于表级锁，主要分为以下三类：</p>
<ul>
<li>  表锁</li>
<li>  元数据锁（meta data lock，MDL）</li>
<li>  意向锁</li>
</ul>
</blockquote>
<h4 id="5-3-2-表锁"><a href="#5-3-2-表锁" class="headerlink" title="5.3.2 表锁"></a><strong>5.3.2</strong> <strong>表锁</strong></h4><blockquote>
<p>对于表锁，分为两类：</p>
<ul>
<li>  表共享读锁（read lock）</li>
<li>  表独占写锁（write lock）</li>
</ul>
<p>语法：</p>
<ul>
<li>  加锁：lock tables 表名… read/write。</li>
<li>  释放锁：unlock tables / 客户端断开连接 。</li>
</ul>
<p>特点 :</p>
<p><strong>A. 读锁</strong></p>
<p><img src="../img/90bbf200239e4a3d825629e6974f22bb.png" srcset="/img/loading.gif" lazyload></p>
<p>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</p>
<p><strong>B. 写锁</strong></p>
<p><img src="../img/5d8ab64cf2ac432c891ae535144570e5.png" srcset="/img/loading.gif" lazyload></p>
<p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p>
</blockquote>
<h4 id="5-3-3-元数据锁"><a href="#5-3-3-元数据锁" class="headerlink" title="5.3.3 元数据锁"></a><strong>5.3.3</strong> <strong>元数据锁</strong></h4><blockquote>
<p>meta data lock , 元数据锁，简写 MDL</p>
<p>MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。 MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免</strong> <strong>DML</strong> <strong>与</strong> <strong>DDL</strong> <strong>冲突，保证读写的正确性</strong></p>
<p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的</p>
<p>在 MySQL5.5 中引入了 MDL ，当对一张表进行增删改查的时候，加 MDL 读锁 ( 共享 ) ；当对表结构进行变更操作的时候，加MDL 写锁 ( 排他 ) 。</p>
<p>常见的 SQL 操作时，所添加的元数据锁：</p>
<table>
<thead>
<tr>
<th><strong>对应</strong> <strong>SQL</strong></th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read /write</td>
<td>SHARED_READ_ONLY /SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、 select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与 SHARED_READ 、SHARED_WRITE 兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、 update 、delete、 select … for update</td>
<td>SHARED_WRITE</td>
<td>与 SHARED_READ 、SHARED_WRITE 兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的 MDL 都互斥</td>
</tr>
</tbody></table>
<p>我们可以通过下面的 SQL ，来查看数据库中的元数据锁的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select object_type,object_schema,object_name,lock_type,lock_duration from<br>performance_schema.metadata_locks ;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-3-4-意向锁"><a href="#5-3-4-意向锁" class="headerlink" title="5.3.4 意向锁"></a><strong>5.3.4</strong> <strong>意向锁</strong></h4><blockquote>
<p>1). 介绍</p>
<p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p>
<p>首先客户端一，开启一个事务，然后执行 DML 操作，在执行 DML 语句时，会对涉及到的行行锁。</p>
<p><img src="../img/6db2a15767d34e71bbd3651a6719730e.png" srcset="/img/loading.gif" lazyload></p>
<p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低</p>
<p>有了意向锁之后 :</p>
<p>客户端一，在执行 DML 操作时，会对涉及的行加行锁，同时也会对该表加上意向锁.</p>
<p><img src="../img/0293b8340ac742de9e3f2c33e877f81e.png" srcset="/img/loading.gif" lazyload></p>
<p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p>
<p>2). 分类</p>
<ul>
<li>  意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li>
<li>  意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li>
</ul>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
<p>可以通过以下 SQL ，查看意向锁及行锁的加锁情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from<br>performance_schema.data_locks;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-4-行级锁"><a href="#5-4-行级锁" class="headerlink" title="5.4 行级锁"></a><strong>5.4</strong> <strong>行级锁</strong></h3><h4 id="5-4-1-介绍"><a href="#5-4-1-介绍" class="headerlink" title="5.4.1 介绍"></a><strong>5.4.1</strong> <strong>介绍</strong></h4><blockquote>
<p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p>
<p>InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p>
<ul>
<li>  行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</li>
</ul>
<p><img src="../img/3d489f96d1ee4bb0a36c99f5a40757f1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li>
</ul>
<p><img src="../img/530c382cfc894f7daa6c59165b89db14.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>  临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li>
</ul>
<p><img src="../img/f1e20d809c8f4bf8ab66f9d9c04cf60f.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="5-4-2-行锁"><a href="#5-4-2-行锁" class="headerlink" title="5.4.2 行锁"></a><strong>5.4.2</strong> <strong>行锁</strong></h4><blockquote>
<p>InnoDB 实现了以下两种类型的行锁：</p>
<ul>
<li>  共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>  排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和他锁</li>
</ul>
<p>两种行锁的兼容情况如下:</p>
<table>
<thead>
<tr>
<th>当前锁类型\请求锁类型</th>
<th>S（共享锁）</th>
<th>X（排他锁）</th>
</tr>
</thead>
<tbody><tr>
<td>S（共享锁）</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X（排他锁）</td>
<td>冲突</td>
<td>冲</td>
</tr>
</tbody></table>
<p>常见的 SQL 语句，在执行时，所加的行锁如下：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT…</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE…</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE…</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT （正常）</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在 SELECT 之后加 LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在 SELECT 之后加 FOR UPDATE</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="5-4-3-间隙锁-amp-临键锁"><a href="#5-4-3-间隙锁-amp-临键锁" class="headerlink" title="5.4.3 间隙锁&amp;临键锁"></a><strong>5.4.3</strong> <strong>间隙锁</strong>&amp;临键锁</h4><blockquote>
<p>                默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行， InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<p>        *   索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。<br>        *   索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。<br>        *   索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p>
<p>        注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
<p>        *   A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p>
<p>        *   B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁.</p>
<p>         我们知道InnoDB 的 B+ 树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18 的数据，并加上共享锁，我们是只锁定 18 这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18 的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29 ）。此时会对 18 加临键锁，并对 29 之前的间隙加锁。</p>
<p>        <img src="../img/5dbcbc91f02f45aea323ea9caab56816.png" srcset="/img/loading.gif" lazyload></p>
<p>        *   C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p>
<p>        查询的条件为 id&gt;=19 ，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：</p>
<p>        [19]</p>
<p>        (19,25]</p>
<p>        (25,+∞]</p>
<p>        所以数据库数据在加锁是，就是将 19 加了行锁， 25 的临键锁（包含 25 及 25 之前的间隙），正无穷的临键锁( 正无穷及之前的间隙 ) 。</p>
</blockquote>
<h2 id="6-InnoDB引擎"><a href="#6-InnoDB引擎" class="headerlink" title="6. InnoDB引擎"></a>6. InnoDB引擎</h2><h3 id="6-1-逻辑存储结构"><a href="#6-1-逻辑存储结构" class="headerlink" title="6.1 逻辑存储结构"></a><strong>6.1</strong> <strong>逻辑存储结构</strong></h3><p>InnoDB 的逻辑存储结构如下图所示 :</p>
<p><img src="../img/478d9eb4a77a428eb2e90213b6db9589.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>  表空间</li>
</ul>
<p>表空间是InnoDB 存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table( 在8.0版本中默认开启 ) ，则每张表都会有一个表空间（ xxx.ibd ），一个 mysql 实例可以对应多个表空间，用于存储记录、索引等数据。</p>
<ul>
<li>  段</li>
</ul>
<p>段，分为数据段（ Leaf node segment ）、索引段（ Non-leaf node segment ）、回滚段（Rollback segment ）， InnoDB 是索引组织表，数据段就是 B+ 树的叶子节点， 索引段即为 B+ 树的非叶子节点。段用来管理多个Extent （区）。</p>
<ul>
<li>  区</li>
</ul>
<p>区，表空间的单元结构，每个区的大小为 1M 。 默认情况下， InnoDB 存储引擎页大小为 16K ， 即一个区中一共有64 个连续的页。</p>
<ul>
<li>  行</li>
</ul>
<p>行， InnoDB 存储引擎数据是按行进行存放的。</p>
<p>在行中，默认有两个隐藏字段：</p>
<p>        <strong>Trx_id</strong>：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</p>
<p>        <strong>Roll_pointer</strong>：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
</blockquote>
<h3 id="6-2-架构"><a href="#6-2-架构" class="headerlink" title="6.2 架构"></a><strong>6.2</strong> <strong>架构</strong></h3><h4 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a><strong>6.2.1</strong> <strong>概述</strong></h4><blockquote>
<p>MySQL5.5 版本开始，默认使用 InnoDB 存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB 架构图，左侧为内存结构，右侧为磁盘结构</p>
<p><img src="../img/26dc205e0d4a44ff9dc1cc0bb82b1fab.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="6-2-2-内存结构"><a href="#6-2-2-内存结构" class="headerlink" title="6.2.2 内存结构"></a><strong>6.2.2</strong> <strong>内存结构</strong></h4><blockquote>
<p><img src="../img/b097840d3074434898b300e676491a08.png" srcset="/img/loading.gif" lazyload></p>
<p>在上侧的内存结构中，主要分为这么四大块儿： <strong>Buffer Pool、Change Buffer、Adaptive</strong></p>
<p><strong>Hash Index、Log Buffer</strong> 。 接下来介绍一下这四个部分</p>
</blockquote>
<h5 id="1-Buffer-Pool"><a href="#1-Buffer-Pool" class="headerlink" title="1). Buffer Pool"></a><strong>1). Buffer Pool</strong></h5><blockquote>
<p>InnoDB 存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O 效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O 。</p>
<p>在 InnoDB 的缓冲池中不仅缓存了索引页和数据页，还包含了 undo 页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p>
<p>缓冲池 Buffer Pool ，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO ，加快处理速度。</p>
<p>缓冲池以 Page 页为单位，底层采用链表数据结构管理 Page 。根据状态，将 Page 分为三种类型：</p>
<ul>
<li>  free page：空闲page，未被使用。</li>
<li>  clean page：被使用page，数据没有被修改过。</li>
<li>  dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li>
</ul>
<p>在专用服务器上，通常将多达 80 ％的物理内存分配给缓冲池 。</p>
<p>参数设置： show variables like ‘innodb_buffer_pool_size’;</p>
</blockquote>
<h5 id="2-Change-Buffer"><a href="#2-Change-Buffer" class="headerlink" title="2). Change Buffer"></a>2). Change Buffer</h5><blockquote>
<p>Change Buffer ，更改缓冲区（针对于非唯一二级索引页），在执行 DML 语句时，如果这些数据 Page没有在Buffer Pool 中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool 中，再将合并后的数据刷新到磁盘中</p>
<p>Change Buffer 的意义是什么呢 ?</p>
</blockquote>
<p>先来看一幅图，这个是二级索引的结构图：</p>
<p><img src="../img/a7b35665340746e19fd27ecfed0737f3.png" srcset="/img/loading.gif" lazyload></p>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO 。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘 IO</p>
<h5 id="3-Adaptive-Hash-Index"><a href="#3-Adaptive-Hash-Index" class="headerlink" title="3). Adaptive Hash Index"></a>3). Adaptive Hash Index</h5><blockquote>
<p>自适应 hash 索引，用于优化对 Buffer Pool 数据的查询。 MySQL 的 innoDB 引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应 hash 索引。因为前面我们讲到过， hash 索引在进行等值匹配时，一般性能是要高于B+ 树的，因为 hash 索引一般只需要一次 IO 即可，而 B+ 树，可能需要几次匹配，所以hash 索引的效率要高，但是 hash 索引又不适合做范围查询、模糊匹配等。</p>
<p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下 hash 索引可以提升速度，则建立hash 索引，称之为自适应 hash 索引。</p>
<p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</strong></p>
<p>参数： adaptive_hash_index</p>
</blockquote>
<h5 id="4-Log-Buffer"><a href="#4-Log-Buffer" class="headerlink" title="4). Log Buffer"></a>4). Log Buffer</h5><blockquote>
<p>Log Buffer ：日志缓冲区，用来保存要写入到磁盘中的 log 日志数据（ redo log 、 undo log ），</p>
<p>默认大小为 16MB ，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O 。</p>
<p>参数 :</p>
<p>innodb_log_buffer_size：                缓冲区大小</p>
<p>innodb_flush_log_at_trx_commit ： 日志刷新到磁盘时机，取值主要包含以下三个：</p>
<ul>
<li>  1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</li>
<li>  0: 每秒将日志写入并刷新到磁盘一次。</li>
<li>  2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li>
</ul>
<p><img src="../img/fc965b2c8f874d0ea824671059b99e9b.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="6-2-3-磁盘结构"><a href="#6-2-3-磁盘结构" class="headerlink" title="6.2.3 磁盘结构"></a><strong>6.2.3</strong> <strong>磁盘结构</strong></h4><p>接下来，再来看看 InnoDB 体系结构的右边部分，也就是磁盘结构</p>
<p><img src="../img/0f319fa1a39d48afa2d76e8eb4fdb09f.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="1-System-Tablespace"><a href="#1-System-Tablespace" class="headerlink" title="1). System Tablespace"></a>1). System Tablespace</h5><blockquote>
<p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。( 在 MySQL5.x 版本中还包含 InnoDB 数据字典、 undolog 等 )</p>
<p>参数： innodb_data_file_path</p>
<p><img src="../img/ccbc75cf027644ddbb84d601d23ca4da.png" srcset="/img/loading.gif" lazyload></p>
<p>系统表空间，默认的文件名叫 ibdata1 。</p>
</blockquote>
<h5 id="2-File-Per-Table-Tablespaces"><a href="#2-File-Per-Table-Tablespaces" class="headerlink" title="2). File-Per-Table Tablespaces"></a>2). File-Per-Table Tablespaces</h5><blockquote>
<p>如果开启了 innodb_file_per_table 开关 ，则每个表的文件表空间包含单个 InnoDB 表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p>
<p>开关参数： innodb_file_per_table ，该参数默认开启。</p>
<p>那也就是说，我们没创建一个表，都会产生一个表空间文件，如图：</p>
<p><img src="../img/62a8f1d6be984cb6b3c7fe425a95536d.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h5 id="3-General-Tablespaces"><a href="#3-General-Tablespaces" class="headerlink" title="3). General Tablespaces"></a>3). General Tablespaces</h5><blockquote>
<p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p>
<p>A. 创建表空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLESPACE ts_name ADD DATAFILE &#x27;file_name&#x27; ENGINE = engine_name;<br></code></pre></td></tr></table></figure>

<p>B. 创建表时指定表空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE xxx ... TABLESPACE ts_name;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="4-Undo-Tablespaces"><a href="#4-Undo-Tablespaces" class="headerlink" title="4). Undo Tablespaces"></a>4). Undo Tablespaces</h5><blockquote>
<p>撤销表空间， MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小 16M ），用于存储undo log日志。</p>
</blockquote>
<h5 id="5-Temporary-Tablespaces"><a href="#5-Temporary-Tablespaces" class="headerlink" title="5). Temporary Tablespaces"></a>5). Temporary Tablespaces</h5><blockquote>
<p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>
</blockquote>
<h5 id="6-Doublewrite-Buffer-Files"><a href="#6-Doublewrite-Buffer-Files" class="headerlink" title="6). Doublewrite Buffer Files"></a>6). Doublewrite Buffer Files</h5><blockquote>
<p>双写缓冲区， innoDB 引擎将数据页从 Buffer Pool 刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</p>
</blockquote>
<h5 id="7-Redo-Log"><a href="#7-Redo-Log" class="headerlink" title="7). Redo Log"></a>7). Redo Log</h5><blockquote>
<p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（ redo log buffer）以及重做日志文件（ redo log ） , 前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时 , 发生错误时 , 进行数据恢复使用。</p>
<p>以循环方式写入重做日志文件，涉及两个文件：</p>
<p><img src="../img/bbfb138dce054c54ac505d5ba599942e.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="6-2-4-后台线程"><a href="#6-2-4-后台线程" class="headerlink" title="6.2.4 后台线程"></a><strong>6.2.4</strong> <strong>后台线程</strong></h4><p>前面我们介绍了 InnoDB 的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB 中涉及到的后台线程。</p>
<p><img src="../img/6b778d6e8b054fa391896f11ea801130.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="../img/88c44611ca854578bc75a755d694c7a9.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>在 InnoDB 的后台线程中，分为 4 类，分别是：</p>
<ul>
<li>  <strong>Master Thread</strong> </li>
<li>  <strong>IO Thread</strong></li>
<li>  <strong>Purge Thread</strong></li>
<li>  <strong>Page Cleaner Thread</strong></li>
</ul>
</blockquote>
<h5 id="1-Master-Thread"><a href="#1-Master-Thread" class="headerlink" title="1). Master Thread"></a>1). Master Thread</h5><blockquote>
<p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中 , 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo 页的回收 。</p>
</blockquote>
<h5 id="2-IO-Thread"><a href="#2-IO-Thread" class="headerlink" title="2). IO Thread"></a>2). IO Thread</h5><blockquote>
<p>在 InnoDB 存储引擎中大量使用了 AIO 来处理 IO 请求 , 这样可以极大地提高数据库的性能，而 IOThread主要负责这些 IO 请求的回调。</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>Read thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert buffer thread</td>
<td>1</td>
<td>负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody></table>
<p>我们可以通过以下的这条指令，查看到 InnoDB 的状态信息，其中就包含 IO Thread 信息。</p>
<ul>
<li>  show engine innodb status \G;</li>
</ul>
<p><img src="../img/45e010a9a0bf4806bfeac7c3b545bea8.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h5 id="3-Purge-Thread"><a href="#3-Purge-Thread" class="headerlink" title="3). Purge Thread"></a>3). Purge Thread</h5><blockquote>
<p>主要用于回收事务已经提交了的 undo log ，在事务提交之后， undo log 可能不用了，就用它来回收。</p>
</blockquote>
<h5 id="4-Page-Cleaner-Thread"><a href="#4-Page-Cleaner-Thread" class="headerlink" title="4). Page Cleaner Thread"></a>4). Page Cleaner Thread</h5><blockquote>
<p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p>
</blockquote>
<h3 id="6-3-事务原理"><a href="#6-3-事务原理" class="headerlink" title="6.3 事务原理"></a><strong>6.3</strong> <strong>事务原理</strong></h3><h4 id="6-3-1-事务基础"><a href="#6-3-1-事务基础" class="headerlink" title="6.3.1 事务基础"></a><strong>6.3.1</strong> <strong>事务基础</strong></h4><blockquote>
<p>1). 事务</p>
<p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>2). 特性</p>
<ul>
<li>  原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>  一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>  隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的立环境下运行。</li>
<li>  持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>那实际上，我们研究事务的原理，就是研究 MySQL 的 InnoDB 引擎是如何保证事务的这四大特性的。</p>
<p><img src="../img/c14afbc4d4644508a16c5a1b61c8ab45.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由 InnoDB 中的两份日志来保证的，一份是redo log 日志，一份是 undo log 日志。 而持久性是通过数据库的锁，加上MVCC 来保证的。</p>
<p><img src="../img/ce619ddac6d444478138bdea36b46da2.png" srcset="/img/loading.gif" lazyload></p>
<p>我们在讲解事务原理的时候，主要就是来研究一下 redolog ， undolog 以及 MVCC 。</p>
<p>3).事务隔离级别</p>
<p>隔离级别定义了一个事务对其他并发事务的可见性和影响范围。MySQL提供了四个标准的隔离级别：</p>
<ol>
<li><strong>读未提交（Read Uncommitted）</strong>：事务可以读取其他事务尚未提交的脏数据。这是最低的隔离级别，存在脏读、不可重复读和幻读的问题。</li>
<li><strong>读已提交（Read Committed）</strong>：事务只能读取其他事务已经提交的数据。避免了脏读，但仍然可能产生不可重复读和幻读问题。</li>
<li><strong>可重复读（Repeatable Read）</strong>：在同一事务中多次读取相同的数据，将得到一致的结果。其他事务对该数据的修改在该事务结束前是不可见的。解决了不可重复读的问题，但仍可能出现幻读。</li>
<li><strong>串行化（Serializable）</strong>：最高的隔离级别，确保事务串行执行，避免了脏读、不可重复读和幻读的问题。但并发性能较差，一般情况下很少使用。</li>
</ol>
<p>小问题：哪种隔离级别好？该如何选择合适的隔离级别？</p>
<table>
<thead>
<tr>
<th></th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>最低级别</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Read Committed</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Serializable</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h4 id="6-3-2-redo-log"><a href="#6-3-2-redo-log" class="headerlink" title="6.3.2 redo log"></a><strong>6.3.2 redo log</strong></h4><blockquote>
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性</p>
<p>该日志文件由两部分组成：重做日志缓冲（ redo log buffer ）以及重做日志文件（ redo log</p>
<p>file ） , 前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中 , 用于在刷新脏页到磁盘, 发生错误时 , 进行数据恢复使用。</p>
<p>如果没有 redolog ，可能会存在什么问题的？ 我们一起来分析一下</p>
<p>        我们知道，在InnoDB 引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB 引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>
<p><img src="../img/8374ccc68adb44bebff22cb209686575.png" srcset="/img/loading.gif" lazyload></p>
<p>那么，如何解决上述的问题呢？ 在 InnoDB 中提供了一份日志 redo log ，接下来我们再来分析一下，通过redolog 如何解决这个问题。</p>
<p><img src="../img/0d2140662ae2475cbb8ba4a72d15402c.png" srcset="/img/loading.gif" lazyload></p>
<p>        有了redolog 之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在 redolog buffer中。在事务提交时，会将 redo log buffer 中的数据刷新到 redo log 磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log 进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog 就没有作用了，就可以删除了，所以存在的两个 redolog 文件是循环写的。</p>
<p>那为什么每一次提交事务，要刷新 redo log 到磁盘中呢，而不是直接将 buffer pool 中的脏页刷新到磁盘呢 ?</p>
<p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而 redo log 在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL （ Write-Ahead Logging ）。</p>
</blockquote>
<h4 id="6-3-3-undo-log"><a href="#6-3-3-undo-log" class="headerlink" title="6.3.3 undo log"></a><strong>6.3.3 undo log</strong></h4><blockquote>
<p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚 ( 保证事务的原子性 ) 和</p>
<p>MVCC( 多版本并发控制 ) 。</p>
<p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时， undolog中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的update记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>Undo log 销毁： undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log ，因为这些日志可能还用于MVCC。</p>
<p>Undo log 存储： undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024 个 undo log segment 。</p>
</blockquote>
<h3 id="6-4-MVCC"><a href="#6-4-MVCC" class="headerlink" title="6.4 MVCC"></a><strong>6.4 MVCC</strong></h3><h4 id="6-4-1-基本概念"><a href="#6-4-1-基本概念" class="headerlink" title="6.4.1 基本概念"></a><strong>6.4.1</strong> <strong>基本概念</strong></h4><blockquote>
<p><strong>1).</strong> <strong>当前读</strong></p>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode( 共享锁 ) ， select …</p>
<p>for update 、 update 、 insert 、 delete( 排他锁 ) 都是一种当前读</p>
<p><strong>2). 快照读</strong></p>
<p>简单的 select （不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p>
<ul>
<li>  Read Committed：每次select，都生成一个快照读。</li>
<li>  <strong>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</strong></li>
<li>  Serializable：快照读会退化为当前读。</li>
</ul>
<p><strong>3). MVCC</strong></p>
<p>全称 Multi-Version Concurrency Control ，多版本并发控制。指维护一个数据的多个版本，</p>
<p>使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。 MVCC 的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 日志、 readView 。</p>
</blockquote>
<h4 id="6-4-2-隐藏字段"><a href="#6-4-2-隐藏字段" class="headerlink" title="6.4.2 隐藏字段"></a><strong>6.4.2</strong> <strong>隐藏字段</strong></h4><h5 id="6-4-2-1-介绍"><a href="#6-4-2-1-介绍" class="headerlink" title="6.4.2.1 介绍"></a><strong>6.4.2.1</strong> <strong>介绍</strong></h5><blockquote>
<p><img src="../img/1401e1576cc647298e3f5bcd4e3e2942.png" srcset="/img/loading.gif" lazyload></p>
<p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这两个个字段以外，InnoDB 还会自动的给我们添加三个隐藏字段及其含义分别是：</p>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务 ID ，记录插入这条记录或最后一次修改该记录的事务 ID 。</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合 undo log ，指向上一个版本。</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td>
</tr>
</tbody></table>
<p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段 DB_ROW_ID ，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p>
</blockquote>
<h5 id="6-4-2-2-测试"><a href="#6-4-2-2-测试" class="headerlink" title="6.4.2.2 测试"></a><strong>6.4.2.2</strong> <strong>测试</strong></h5><blockquote>
<p>查看有主键的表 coursr</p>
<p>进入服务器中的 /var/lib/mysql/itcast/ , 查看 stu 的表结构信息 , 通过如下指令 :</p>
<p><strong>ibd2sdi course.ibd</strong></p>
<p>查看到的表结构信息中，有一栏 columns ，在其中我们会看到处理我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，<strong>因为该表有主键</strong>，所以没有 DB_ROW_ID隐藏字段。</p>
<p><img src="../img/c29f09a93cb94b96af7f1988fc46748c.png" srcset="/img/loading.gif" lazyload> <img src="../img/52ca46b2ea834a0bac48e5049a133220.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="../img/d6d4059e4e164312bace58760ce37b7e.png" srcset="/img/loading.gif" lazyload> <img src="../img/cdbd83f212f242a4a79c78a977014f11.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="6-4-3-undolog"><a href="#6-4-3-undolog" class="headerlink" title="6.4.3 undolog"></a><strong>6.4.3 undolog</strong></h4><h5 id="6-4-3-1-介绍"><a href="#6-4-3-1-介绍" class="headerlink" title="6.4.3.1 介绍"></a><strong>6.4.3.1</strong> <strong>介绍</strong></h5><blockquote>
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除</p>
</blockquote>
<h5 id="6-4-3-2-版本链"><a href="#6-4-3-2-版本链" class="headerlink" title="6.4.3.2 版本链"></a><strong>6.4.3.2</strong> <strong>版本链</strong></h5><blockquote>
<p>有一张表原始数据为：</p>
<p><img src="../img/75caa8dfcb104531a00f287f30ca2c42.png" srcset="/img/loading.gif" lazyload></p>
<p>DB_TRX_ID : 代表最近修改事务 ID ，记录插入这条记录或最后一次修改该记录的事务 ID ，是</p>
<p>自增的。</p>
<p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为 null 。</p>
<p>然后，有四个并发事务同时在访问这张表</p>
<p>A. 第一步</p>
<p><img src="../img/0462635f13a54edd9fb6a73605a97e72.png" srcset="/img/loading.gif" lazyload></p>
<p>当事务 2 执行第一条修改语句时，会记录 undo log 日志，记录数据变更之前的样子 ; 然后更新记录，并且记录本次操作的事务ID ，<strong>回滚指针</strong>，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src="../img/0db65e6666ea45e5989b399c96a4cf62.png" srcset="/img/loading.gif" lazyload></p>
<p>B. 第二步</p>
<p><img src="../img/b1fa7fd1cae248b7ba5aaa9b4d4d7535.png" srcset="/img/loading.gif" lazyload></p>
<p>当事务 3 执行第一条修改语句时，也会记录 undo log 日志，记录数据变更之前的样子 ; 然后更新记录，并且记录本次操作的事务ID ，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src="../img/38fd6276c89943f7be07e5dcc7113e84.png" srcset="/img/loading.gif" lazyload></p>
<p>C. 第三步</p>
<p><img src="../img/4fb79eda60ef4b638bed5372c4aaf80a.png" srcset="/img/loading.gif" lazyload></p>
<p>当事务 4 执行第一条修改语句时，也会记录 undo log 日志，记录数据变更之前的样子 ; 然后更新记录，并且记录本次操作的事务ID ，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src="../img/84f566d5699b4ac796eb84d177c6fb17.png" srcset="/img/loading.gif" lazyload></p>
<p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的 undolog 生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>
</blockquote>
<h4 id="6-4-4-readview"><a href="#6-4-4-readview" class="headerlink" title="6.4.4 readview"></a><strong>6.4.4 readview</strong></h4><blockquote>
<p>ReadView （读视图）是 快照读 SQL 执行时 MVCC 提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id 。</p>
<p>ReadView 中包含了四个核心字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃的事务ID集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务 ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务 ID ，当前最大事务 ID+1 （因为事务 ID 是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView 创建者的事务 ID</td>
</tr>
</tbody></table>
<p>而在 readview 中就规定了版本链数据的访问规则：</p>
<p>trx_id 代表当前 undolog 版本链对应事务 ID 。</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>是否可以访问</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id == creator_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据是当前这个事务更改的。</td>
</tr>
<tr>
<td>trx_id &lt; min_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据已经提了。</td>
</tr>
<tr>
<td>trx_id &gt; max_trx_id</td>
<td>不 可以访问该版本</td>
<td>成立，说明该事务是在 ReadView生成后才开启。</td>
</tr>
<tr>
<td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td>
<td>如果 trx_id 不在 m_ids 中，是可以访问该版本的</td>
<td>成立，说明数据已经提交。</td>
</tr>
</tbody></table>
<p>不同的隔离级别，生成 ReadView 的时机不同：</p>
<ul>
<li>  READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li>
<li>  REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li>
</ul>
</blockquote>
<h4 id="6-4-5-原理分析"><a href="#6-4-5-原理分析" class="headerlink" title="6.4.5 原理分析"></a><strong>6.4.5</strong> <strong>原理分析</strong></h4><h5 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a><strong>6.4.5.1 RC</strong>隔离级别</h5><blockquote>
<p>RC隔离级别下，在事务中<strong>每一次执行</strong>快照读时生成ReadView。</p>
<p>我们就来分析事务 5 中，两次快照读读取数据，是如何获取数据的 ?</p>
<p>在事务 5 中，查询了两次 id 为 30 的记录，由于隔离级别为 Read Committed ，所以每一次进行快照读都会生成一个ReadView ，那么两次生成的 ReadView 如下。</p>
<p><img src="../img/23523826d6b04c439c13b1e3fc7ac06a.png" srcset="/img/loading.gif" lazyload></p>
<p>那么这两次快照读在获取数据时，就需要根据所生成的 ReadView 以及 ReadView 的版本链访问规则，到undolog 版本链中匹配数据，最终决定此次快照读返回的数据。</p>
</blockquote>
<p><strong>A. 先来看第一次快照读具体的读取过程：</strong></p>
<p><img src="../img/10e147d17a95458fbe8a3d5f17a0afc9.png" srcset="/img/loading.gif" lazyload></p>
<p>在进行匹配时，会从 undo log 的版本链，从上到下进行挨个匹配：</p>
<ul>
<li>  先匹配<img src="../img/a0f200cda95a47a39e8ce14829ca71cf.png" srcset="/img/loading.gif" lazyload>这条记录，这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li>
<li>  再匹配第二条<img src="../img/79121bb4e81e4793adee57bec8fdf72a.png" srcset="/img/loading.gif" lazyload>，这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li>
<li>  再匹配第三条<img src="../img/16b6b79692ab45f5b7823a4459f1a3cb.png" srcset="/img/loading.gif" lazyload>，这条记录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</li>
</ul>
<p><strong>B. 再来看第二次快照读具体的读取过程:</strong></p>
<p><img src="../img/cf9f6274ce6749cfb318f3d2fb284a60.png" srcset="/img/loading.gif" lazyload></p>
<p>在进行匹配时，会从 undo log 的版本链，从上到下进行挨个匹配：</p>
<ul>
<li>  先匹配<img src="../img/fd42f0e90b0843e9b1ec1bae93aeab03.png" srcset="/img/loading.gif" lazyload>这条记录，这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li>
<li>  再匹配第二条<img src="../img/258aa99f52e846e8b9224002681e26ae.png" srcset="/img/loading.gif" lazyload>，这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</li>
</ul>
<h5 id="6-4-5-3-RR隔离级别"><a href="#6-4-5-3-RR隔离级别" class="headerlink" title="6.4.5.3 RR隔离级别"></a><strong>6.4.5.3 RR</strong>隔离级别</h5><blockquote>
<p>RR 隔离级别下，仅在事务中第一次执行快照读时生成 ReadView ，后续复用该 ReadView 。 而 RR 是可重复读，在一个事务中，执行两次相同的select 语句，查询到的结果是一样的。</p>
<p>那 MySQL 是如何做到可重复读的呢 ? 我们简单分析一下就知道了</p>
<p><img src="../img/491ac9714c3b45cebe2044cdfab600ba.png" srcset="/img/loading.gif" lazyload></p>
<p>我们看到，在 RR 隔离级别下，只是在事务中第一次快照读时生成 ReadView ，后续都是复用该 ReadView，那么既然 ReadView 都一样， ReadView 的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p>
</blockquote>
<p>所以呢， MVCC 的实现原理就是通过 InnoDB 表的隐藏字段、 UndoLog 版本链、 ReadView 来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由 redolog 与 undolog 保证。</p>
<p><img src="../img/1f8161407d644fa58f7c5ea8fc0b48d6.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="7-面试题整理"><a href="#7-面试题整理" class="headerlink" title="7.面试题整理"></a>7.面试题整理</h2><ol>
<li><p>事务acid（滴滴+）</p>
</li>
<li><p>b+树为什么快</p>
</li>
<li><p>b+树非子节点保存的数据，b+树子节点保存的数据</p>
</li>
<li><p>AVL树</p>
</li>
<li><p>AVL树和b+树区别</p>
</li>
<li><p>MySQL事务的特性和隔离级别</p>
</li>
<li><p>MySQL索引有哪些？</p>
</li>
<li><p>聚簇索引和非聚簇索引区别</p>
</li>
<li><p>MySQL底层结构</p>
</li>
<li><p>B+树怎么保持平衡？</p>
</li>
<li><p>MySQL的存储引擎有哪些以及区别？</p>
</li>
<li><p>MySQL基础架构</p>
<ol>
<li>连接器</li>
<li>分析器</li>
<li>优化器</li>
<li>执行器</li>
<li>查询缓存</li>
<li>存储引擎</li>
</ol>
</li>
<li><p>Mysql优化</p>
</li>
<li><p>MySQL设计一个抢单系统，不用那个其他<br>​</p>
<p>附网址 <a target="_blank" rel="noopener" href="https://achaoan.github.io/2021/08/18/Mysql%E5%9F%BA%E7%A1%80%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">MySQL基础及相关问题</a></p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/">数据库进阶</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/%E9%9D%A2%E8%AF%95/MySQL/">MySQL</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/15/Kywq%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E5%8F%8A%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"TPHaN5RwHJvIScPkuQebPPcl-gzGzoHsz","appKey":"bhjOS1d63fgfgDX19J1XKDGl","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
